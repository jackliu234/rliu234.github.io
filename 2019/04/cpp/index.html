<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Notes on C++ · Rongjia Liu</title><meta name="description" content="Notes on C++ - Rongjia Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/arctic.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jackliu234.com/atom.xml" title="Rongjia Liu"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><!-- li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") <i class="fa fa-search" aria-hidden="true"></i>--></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Notes on C++</h1><div class="post-info"><!-- if is_post()--><!--     span &#128197; &nbsp;-->Apr 6, 2019<!-- if is_post()--><!--    span#busuanzi_container_page_pv | &#128065;--><!--    span#busuanzi_value_page_pv--><!--    if item.tags--><!--        span | &nbsp;--><!--        for tag in item.tags.toArray()--><!--            a(href=url_for(tag.path))=  '#' + tag.name--><!-- if item.from && (is_home() || is_post())--><!--    a.post-from(href=item.from target="_blank" title=item.from)!= __('translated')-->
</div><div class="post-content"><p>C++ is a <code>complied</code> （vs interpreted: python), <code>general-purpose</code> (vs domain-specific: HTML) programming language created by Danish programmer <code>Bjarne Stroustrup</code> as an extension to C.</p>
<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>A compiler translate a high level language into a low level language and create an executable program.</p>
<ol>
<li>Pre-processor: read preprocessing lines <code>#include &quot;foo.hpp&quot;</code></li>
<li>Compiler: turn the above code it into assembly code (ASM).<ul>
<li><strong><em>front end</em></strong> create IR (intermediate representation) with SSA (static singale assignment). The runtime is <script type="math/tex">O(n)</script>.</li>
<li><strong><em>middle end</em></strong> optimize IR. remove unnecessary operations, <script type="math/tex">O(n^2)</script> or more.</li>
<li><strong><em>back end</em></strong> produce ASM</li>
</ul>
</li>
<li>Assembler: turn ASM into binary code</li>
<li>Linker: link all relevant headers, libraries together</li>
<li>Debugger: type checking</li>
<li>Object Copy: generate .exe (for windows), and .bin (for mac)</li>
</ol>
<h3 id="G"><a href="#G" class="headerlink" title="G++"></a>G++</h3><p>Compile with g++ at the command line:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ toto.cpp</span><br><span class="line">$ g++ toto.cpp -E (show c pre-processor)</span><br><span class="line">$ g++ toto.cpp --verbose (ask compile to give different steps)</span><br></pre></td></tr></table></figure></p>
<p>Running the complied result:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /a.exe</span><br></pre></td></tr></table></figure></p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>The <code>C++ standard library</code> is a collection of classes and functions, represented by different headers. For example, include the <code>&lt;iostream&gt;</code> header to handle input and outputs and other non-standard headers using double quoto.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Macro"><a href="#Macro" class="headerlink" title="Macro"></a>Macro</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define N <span class="number">4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; N + <span class="number">2</span>; <span class="comment">// show 6</span></span><br></pre></td></tr></table></figure>
<h3 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h3><p>In C++, function, class and variable can only be declared once. We use <code>guards</code> to make sure we do not duplicate declaration in multiple files.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef &quot;foo.h&quot;</span><br><span class="line">#define &quot;foo.h&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Some classes and functions are grouped under the same name, which divides the global scope into sub-scopes, each with its own namespaces.</p>
<p>Functions and classes in the C++ standard library are defined in the <code>std</code> namespace. For example, the <code>cin</code> (standard input), <code>cout</code> (standard output) and <code>end</code> (end line) objects.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>Alternatively, we can use <code>using namespace std;</code>.</p>
<h2 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h2><p>Every variable has to have a <code>type</code> in C++, and the type has to be declared and cannot be changed. There are fundamental types and user-defined types (classes)</p>
<p><strong><em>Characters</em></strong> In computer, each <code>bit</code> stores a binary (0/1) value. A <code>byte</code> is 8 bits.  The computer stores characters in a byte using the <a href="https://www.ascii-code.com" target="_blank" rel="noopener">ASCII</a> format.</p>
<p><strong><em>Numbers</em></strong> The computer stores numbers in binary format with bits. The <code>leftmost</code> bit is used to store the sign of a number. (See <a href="http://en.wikipedia.org/wiki/Two’s_complement" target="_blank" rel="noopener">twos-complement method</a>). Real values are stored using a <code>mantissa</code> and an exponent:</p>
<script type="math/tex; mode=display">Value = Mantissa \times 2^{Exponent}</script><p>Note that very few values can be exactly represented, and how close we can get depends on the number of bits available.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Size (Bytes)</th>
<th>Value Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>1</td>
<td>true or false</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>3.4E +/- 38</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>1.7E +/- 308</td>
</tr>
</tbody>
</table>
</div>
<p>C++ is a <code>strongly typed</code> language, which means type errors needs to be resolved for all variables at <code>compile</code> time.</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Every console application has to have a <code>main()</code> function, which takes no argument and returns an integer value by default.</p>
<p>A function that adds two numbers:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Result: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Overloading</code> allows 2 or more functions to have the same name, but they must have different input argument <code>types</code>.</p>
<h3 id="Function-Object"><a href="#Function-Object" class="headerlink" title="Function Object"></a>Function Object</h3><p>Function object, or <code>functors</code>, are objects that behave like functions, are functions with state.</p>
<p>A regular function looks like this:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddOne</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = AddOne(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>A function object implementaion:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddOne</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AddOne addone;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> result = addone(val)</span><br></pre></td></tr></table></figure></p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Lambdas is a new feature introduced in C++11, which is an inline function that can be used as a parameter or local object.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="built_in">string</span> s) <span class="comment">// [] is the lambda introducer/capture clause</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 1</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">for_each(v.cbegin(), v.cend(),                  <span class="comment">//range</span></span><br><span class="line">         [](<span class="keyword">int</span> elem) &#123;<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;&#125;)  <span class="comment">//lambda</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 2</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">transform(v.begin(), v.end(),</span><br><span class="line">          v.begin(), [] (<span class="keyword">int</span> elem) &#123;<span class="keyword">return</span> elem * elem&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 3</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Person&gt; ppl;</span><br><span class="line">sort(ppl.begin(), ppl.end(),</span><br><span class="line">     [](<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person&amp;p2)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.GetAge() &lt; p2.GetAge()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Extern"><a href="#Extern" class="headerlink" title="Extern"></a>Extern</h3><p>The keyword extern means the function is declared in another file.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo(<span class="number">100</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Inline-Function"><a href="#Inline-Function" class="headerlink" title="Inline Function"></a>Inline Function</h3><p>C++ provides <code>inline</code> funcitons such that the overhead of a small function can be reduced. When inline function is called the entire code of the function is inserted at the point of the inline function call.</p>
<h2 id="Typedef"><a href="#Typedef" class="headerlink" title="Typedef"></a>Typedef</h2><p>Use <code>typedef</code> keyword to define a type alias.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> OptionPrice;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> StockPrice;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Strike;</span><br><span class="line"><span class="function">OptionPrice <span class="title">BSPrice</span><span class="params">(StockPrice S, Strike K)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>Standard operations:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Arithmetic: +, -, *, /</span><br><span class="line">Comparison: &lt;, &gt;, &lt;=, &gt;=</span><br><span class="line">Negate: !</span><br><span class="line">Equality, non Equality: ==, !=</span><br><span class="line">Logical <span class="keyword">and</span>, <span class="keyword">or</span>, &amp;&amp;, ||</span><br><span class="line">Assignment: =</span><br><span class="line">Modulo: %</span><br><span class="line">Increment, Decrement: i++, i--</span><br><span class="line">Multiple Operations: i += <span class="number">1</span>, i -= <span class="number">1</span>, i *= <span class="number">1</span>, i /= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>Note the difference between <code>i++</code> and <code>++i</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++; <span class="comment">// return (old) i and increment i</span></span><br><span class="line">++i; <span class="comment">// increment i and return new i</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>Use the <code>const</code> keyword to define a constant value. The <code>compiler</code> will stop any attempt to alter the constant values.</p>
<p>Since C++ is a strongly typed language, it is preferred to use <code>const int N = 4</code>, instead of <code>#define N 4</code>, as the former defines a type.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><strong><em>Example 1</em></strong> A reference is an alias for a variable and cannot rebind to a different variable. We can change <code>val</code> by changing <code>ref</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = val;</span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">// this will change val to 20</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 2</em></strong> We can also bind a const reference to a const object. An error will be raised if attempt to change the value or the reference.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = val;</span><br><span class="line">val = <span class="number">20</span>; <span class="comment">// error</span></span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 3</em></strong> We can also bind a const reference to a non-const object, thereafter we can NOT change the object using the reference.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = val;</span><br><span class="line">val = <span class="number">20</span>; <span class="comment">// ok</span></span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong><em>Pass By Value</em></strong> In a function, we can pass an argument by either <code>value</code> or <code>reference</code>. When passing by <code>value</code>, the variable <code>x</code> will NOT be changed. In this case, we waste time to both create a copy inside the function and memory to store the copy<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleValue</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    DoubleValue(x);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong><em>Pass By Reference</em></strong> When passing by <code>reference</code> (by adding <code>&amp;</code> in the function argument parameter), the variable <code>x</code> WILL be changed.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleValue</span><span class="params">(<span class="keyword">int</span>&amp; number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    DoubleValue(x);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong><em>Pass By Const Reference</em></strong> We add const when we do not want the specific function argument to be tempered when passed by reference. In this example, there will be a compiler error as we are trying to change the const reference <code>number</code> in the function.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number = number * <span class="number">2</span>; <span class="comment">// error, cannot change const ref "number"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    DoubleValue(x);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h2><p>In computer memory, each stored values has an address associated with it. We use a <code>pointer</code> object to store address of another object and access it indirectly.</p>
<p>There are two pointer operator:</p>
<ol>
<li><code>&amp;</code>: <code>address of</code> operator, used to get the address of an object</li>
<li><code>*</code>: <code>de-reference</code> operator, used to access the object</li>
</ol>
<p><strong><em>Example 1</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="literal">nullptr</span>; <span class="comment">// initiate an empty pointer</span></span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;val; <span class="comment">// initiate ptr with the address of val</span></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// change val using the ptr pointer</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 2</em></strong>  If the object is const, a pointer cannot be used to change it.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr = &amp;val;</span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>Example 3</em></strong>  You can have a pointer that itself is const<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr = &amp;val;</span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">ptr = &amp;val2 <span class="comment">// error, as the pointer is const</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h2><p>C++ allows <code>implicit</code> and <code>explicit</code> conversions of types.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">b = a; <span class="comment">// implicit conversion</span></span><br><span class="line">b = (<span class="keyword">int</span>) a; <span class="comment">// explicit conversion</span></span><br></pre></td></tr></table></figure></p>
<p>However, the traditional explicit type-casting allows conversions between any types, and leads to run-time error. To control these conversions, we introduce four specific casting operators:</p>
<ul>
<li><code>dynamic_cast&lt;new_type&gt;( )</code>: used only with pointers (and/or references to objects); can cast a <code>derived</code> class to its <code>base</code> class; <code>base-to-derived</code> conversions are allowed only with <code>polymorphic</code> base class</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Derived* derived_ptr;</span><br><span class="line">    Base* base_ptr = <span class="keyword">dynamic_cast</span>&lt;Base*&gt; (derived_ptr);</span><br><span class="line"></span><br><span class="line">    Base* base_ptr_2 = <span class="keyword">new</span> Derived;</span><br><span class="line">    Derived* derived_ptr_2 = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt; (base_ptr_2);</span><br><span class="line">    <span class="comment">// ok, base class polymorphic</span></span><br><span class="line"></span><br><span class="line">    Base* base_ptr_3 = <span class="keyword">new</span> Base;</span><br><span class="line">    Derived* derived_ptr_3 = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt; (base_ptr_3);</span><br><span class="line">    <span class="comment">// will not work, derived_ptr_3 will be assigned a nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived_ptr_2: "</span> &lt;&lt; derived_ptr_2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived_ptr_3: "</span> &lt;&lt;  derived_ptr_3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">derived_ptr_2: <span class="number">0x7fa5cec00630</span></span><br><span class="line">derived_ptr_3: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><code>static_cast &lt; new_type&gt;( )</code>: used only with pointers (and/or references to objects); can cast <code>base-to-derived</code> or <code>derived-to-base</code>, but no safety check at run-time;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base* base_ptr_3 = <span class="keyword">new</span> Base;</span><br><span class="line">Derived* derived_ptr_3 = <span class="keyword">static_cast</span>&lt;Derived*&gt; (base_ptr_3);</span><br><span class="line"><span class="comment">// not nullptr this time, but lead to error when de-referencing derived_ptr_3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived_ptr_3: <span class="number">0x7fc3d7400690</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><code>reinterpret_cast &lt;new_type&gt;( )</code>: convert pointer to another unrelated class; often lead to unsafe de-referencing</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">A* a = <span class="keyword">new</span> A;</span><br><span class="line">B* b = <span class="keyword">reinterpret_cast</span>&lt;B*&gt; (a);</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><code>const_cast &lt;new_type&gt;( )</code>: remove/set the constant-ness of an object</li>
</ul>
<h2 id="Array-C-Style"><a href="#Array-C-Style" class="headerlink" title="Array (C-Style)"></a>Array (C-Style)</h2><p>An array is a fixed collection of similar kinds of items that are stored in a contiguous block in memory. We define the size of the array at creation, and the array index starts a 0 in C++.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// uniform initializer syntax</span></span><br></pre></td></tr></table></figure></p>
<p>The address of the array is the same as the address of the first element of the array. Therefore, we can access an array using pointer increment - very efficient.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;a[<span class="number">0</span>]; <span class="comment">// the same as int* ptr = a</span></span><br><span class="line"><span class="keyword">int</span> a0 = a[<span class="number">0</span>]; <span class="comment">// the same as int a0 = *ptr</span></span><br><span class="line"><span class="keyword">int</span> a3 = a[<span class="number">3</span>]; <span class="comment">// the same as int a3 = *(ptr+3) or *(a+3)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Dynamic-Allocation"><a href="#Dynamic-Allocation" class="headerlink" title="Dynamic Allocation"></a>Dynamic Allocation</h2><p><code>Dynamic memory allocation</code> is necessary when you do NOT know the size of the array at compile time. We use a <code>new</code> keyword paired with a <code>delete</code> keyword.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] = a; <span class="comment">// correct. this tells the CPU that it needs to clean up multiple variables instead of a single variable</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">// incorrect. using this version will lead to a memory leak.</span></span><br></pre></td></tr></table></figure></p>
<p>Dynamic allocate a <script type="math/tex">4\times4</script> matrix with cast.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>** a)</span> </span>&#123;</span><br><span class="line">    * a = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (* a)[<span class="number">4</span>];</span><br><span class="line">    func( (<span class="keyword">double</span>**)&amp;a );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">            a[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><p>A C++ <code>library</code> is a package of reusable code typically with these two components:</p>
<ul>
<li>header file</li>
<li>precompiled binary containing the machine code for functionality implemntation</li>
</ul>
<p>There are two types of c++ libraries: <code>static</code> and <code>dynamic</code> libraries.</p>
<ul>
<li>a <code>static</code> library has a <code>.a</code> (<code>.lib</code> on Windows) extension and the library codes are complied as part of the executable - so that user only need to distribute the executable for other users to run the file with a static library.</li>
<li>a <code>dynamic</code> library has a <code>.so</code> (<code>.dll</code> on Windows) extension and is loaded at run times. It saves space as many program can share a copy of dynamic library code, and it can be upgraded to new versions without replacing all the executables using it.</li>
</ul>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><h2 id="If-Else"><a href="#If-Else" class="headerlink" title="If/Else"></a>If/Else</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition_1)</span><br><span class="line">&#123;</span><br><span class="line">   statement1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition_2)</span><br><span class="line">&#123;</span><br><span class="line">  statement2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  statement2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>A switch statement tests an integral or enum value against a set of constants. we can NOT use a string in the switch statement.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">    <span class="keyword">switch</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"value is zero"</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// if remove this break, it will also show case 1 even if value is 0</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"value is one"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"value is not 0 or 1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="While-Do-While-For-Loop"><a href="#While-Do-While-For-Loop" class="headerlink" title="While / Do While / For Loop"></a>While / Do While / For Loop</h2><p>While loop:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" n: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Do while loop:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter number (0 to end): "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; n &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> &#125; <span class="keyword">while</span> (n != <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>For loop:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"n: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For loop with two variables:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; j &lt; <span class="number">10</span>; ++i, j+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i:"</span> &lt;&lt; i &lt;&lt; <span class="string">", j:"</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>The <code>enum</code> (enumerated) type is used to define collections of named integar constants.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CurrencyType &#123;USD, EUR, GBP&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; USD &lt;&lt; <span class="string">" "</span> &lt;&lt; EUR &lt;&lt; <span class="string">" "</span> &lt;&lt; GBP;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> CurrencyType &#123;USD, EUR=<span class="number">10</span>, GBP&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; USD &lt;&lt; <span class="string">" "</span> &lt;&lt; EUR &lt;&lt; <span class="string">" "</span> &lt;&lt; GBP;</span><br><span class="line"><span class="number">0</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>A <code>class</code> achieve data <code>abstraction</code> and <code>encapsulation</code>.</p>
<ul>
<li>abstraction refers to the separation of interface and implementation</li>
<li>encapsulation refers to combining data and functions so that data is only accessible through functions.</li>
</ul>
<h2 id="Member-Variable-amp-Function"><a href="#Member-Variable-amp-Function" class="headerlink" title="Member Variable &amp; Function"></a>Member Variable &amp; Function</h2><p>Define a customer class with member variable and function.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Customer(); <span class="comment">// default constructor</span></span><br><span class="line">    Customer(<span class="built_in">string</span> name, <span class="built_in">string</span> address);</span><br><span class="line">    ~Customer(); <span class="comment">// destructor, to free up resources</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetAddress</span><span class="params">(<span class="built_in">string</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name_;</span><br><span class="line">    <span class="built_in">string</span> address_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Instantiate Customer class instances to represent different customer.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Customer <span class="title">c1</span><span class="params">(<span class="string">"Joe"</span>, <span class="string">"Hyde Park"</span>)</span></span>;</span><br><span class="line"><span class="function">Customer <span class="title">c2</span><span class="params">(<span class="string">"Jim"</span>, <span class="string">"Chicago"</span>)</span></span>;</span><br><span class="line"><span class="function">Customer <span class="title">c3</span><span class="params">(<span class="string">"John"</span>, <span class="string">"New York"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use `.` to access member function.</span></span><br><span class="line">c1.GetName()</span><br><span class="line">c2.SetAddress(<span class="string">"Beijing"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Protection-Level"><a href="#Protection-Level" class="headerlink" title="Protection Level"></a>Protection Level</h2><p>There are three protection levels to keep class data member internal to the class.</p>
<ol>
<li><strong><em>public</em></strong> accessible to all.</li>
<li><strong><em>protected</em></strong> accessible in the class that defines them and in classes that <code>inherit</code> from that class.</li>
<li><strong><em>private</em></strong> only accessible within the class defining them.</li>
</ol>
<h2 id="Constructor-Destructor"><a href="#Constructor-Destructor" class="headerlink" title="Constructor / Destructor"></a>Constructor / Destructor</h2><p>A <code>constructor</code> is a special member functions used to initialize the data members when an object is created. This is an example to use <code>initializer list</code> to create more efficient constructors<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Customer::Customer()</span><br><span class="line">    : name_(<span class="string">""</span>),</span><br><span class="line">    address_(<span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// name_ = "";</span></span><br><span class="line">    <span class="comment">// address_ = "";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Customer::Customer(<span class="built_in">string</span> name, <span class="built_in">string</span> address)</span><br><span class="line">    : name_(name),</span><br><span class="line">    address_(address)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Customer::~Customer()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Free-Store"><a href="#Free-Store" class="headerlink" title="Free-Store"></a>Free-Store</h2><p>There are several ways to create objects on a computer:</p>
<ul>
<li><p><strong><em>Automatic/Stack</em></strong> <code>int a;</code></p>
</li>
<li><p><strong><em>Dynamic Allocated</em></strong></p>
<ul>
<li><strong><em>Free Store</em></strong> <code>int* ptr = new a[10];</code></li>
<li><strong><em>Heap</em></strong> allocated/freed by <code>malloc/free</code></li>
</ul>
</li>
</ul>
<p>Summarized in a table from <a href="https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/" target="_blank" rel="noopener">geeksforgeeks</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Stack</th>
<th>Heap</th>
</tr>
</thead>
<tbody>
<tr>
<td>Basic</td>
<td>Memory is allocated in a contiguous block</td>
<td>Memory is allocated in any random order</td>
</tr>
<tr>
<td>Allocated and de-allocation</td>
<td>Automatic by compiler instructions</td>
<td>Manual by programmer</td>
</tr>
<tr>
<td>Cost</td>
<td>Less</td>
<td>More</td>
</tr>
<tr>
<td>Access time</td>
<td>Faster</td>
<td>Slower</td>
</tr>
<tr>
<td>Main issue</td>
<td>Shortage of memory</td>
<td>Memory leak/fragmentation</td>
</tr>
</tbody>
</table>
</div>
<p>We use <code>-&gt;</code> to access free-store object’s member functions:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Customer* c = <span class="keyword">new</span> Customer(<span class="string">"Joe"</span>, <span class="string">"Chicago"</span>);</span><br><span class="line">c-&gt;GetName()</span><br><span class="line">c-&gt;SetAddress(<span class="string">"New York"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Const-Member-Functions"><a href="#Const-Member-Functions" class="headerlink" title="Const Member Functions"></a>Const Member Functions</h2><p>A <code>const object</code> can only invoke <code>const member function</code> on the class. A const member function is not allowed to modify any of the data members on the object on which it is invoked. However, if a data member is marked <code>mutable</code>, it then can be modified inside a const member function.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Customer <span class="title">c1</span><span class="params">(<span class="string">"Joe"</span>, <span class="string">"Hyde Park"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c1.GetName(); <span class="comment">// ok if GetName() is a const member function.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Static-Member"><a href="#Static-Member" class="headerlink" title="Static Member"></a>Static Member</h2><p>We use <code>static</code> keyword to associate a member with the class, as oppose to class instances. A static data member can NOT be accessed directly using a non-static member function.</p>
<p>Static member variables can NOT be initialized through the class constructor, rather, they are initialized once outside the class body. However, a const static member variable can be initialized within the class body.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Counter();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count_; <span class="comment">// non-const static need to be initialized outside</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> count_2_ = <span class="number">0</span>; <span class="comment">// const static can be initialized within</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Counter::count_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Counter c;</span><br><span class="line">c.Increment(); <span class="comment">// or Counter::Increment()</span></span><br></pre></td></tr></table></figure></p>
<h2 id="This"><a href="#This" class="headerlink" title="This"></a>This</h2><p>Every non-static member function has access to a <code>this</code> pointer, which is initialized with the address of the object when the member function is invoked.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Currency::GetExchangeRate()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> exchangeRate_;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>-&gt;exchangeRate_; <span class="comment">// equivalent</span></span><br><span class="line">   <span class="keyword">return</span> (*<span class="keyword">this</span>).exchangeRate_; <span class="comment">// equivalent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Copy-Constructor"><a href="#Copy-Constructor" class="headerlink" title="Copy Constructor"></a>Copy Constructor</h2><p>We use the copy constructor to construct an object from another already constructed object of the same type.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; other)</span><br><span class="line">    : name_(other.name_)</span><br><span class="line">    address_(other.address_)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Customer <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="Assignment-Operator"><a href="#Assignment-Operator" class="headerlink" title="Assignment Operator"></a>Assignment Operator</h2><p>We use the assignment operator to assign an object of the same type.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)  <span class="comment">//checking for self assignment</span></span><br><span class="line">   &#123;</span><br><span class="line">       name_    =  other.name_;</span><br><span class="line">       address_ =  other.address_;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//return the object on which the function was invoked</span></span><br><span class="line">   <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Shallow-Deep-Copy"><a href="#Shallow-Deep-Copy" class="headerlink" title="Shallow / Deep Copy"></a>Shallow / Deep Copy</h2><p>The default copy constructor and assignment operator provides <code>shallow copy</code>, which copies each member of the class individually. For pointer member, the shallow copying copies the address of the pointer, resulting in both members pointing to the same object on the free store.</p>
<p>A <code>deep copy</code>, however, creates a new object on the free store and copy the contents of the object the original pointer is pointing to.</p>
<p><strong><em>Deep Copy</em></strong> copy constructor<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; other)</span><br><span class="line">    :name_(other.name_),</span><br><span class="line">     address_(other.address_),</span><br><span class="line">     account_(<span class="keyword">new</span> Account(other.account_-&gt;GetAccountNumber(),</span><br><span class="line">              other.account_-&gt;GetAccountBalance()))</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>Deep Copy</em></strong> assignment operator<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">       name_ = other.name_;</span><br><span class="line">       address_ = other.address_;</span><br><span class="line">       <span class="keyword">delete</span> account_;</span><br><span class="line">       account_= <span class="keyword">new</span> Account(other.account_-&gt;GetAccountNumber(),</span><br><span class="line">                           other.account_-&gt;GetAccountBalance());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="The-Rule-of-3"><a href="#The-Rule-of-3" class="headerlink" title="The Rule of 3"></a>The Rule of 3</h2><p>There are 3 operations that control the copies of an object: copy constructor, assignment operator, and destructor. If you define one of them, you will most likely need to define the other two as well.</p>
<h2 id="Singleten-Class"><a href="#Singleten-Class" class="headerlink" title="Singleten Class"></a>Singleten Class</h2><p>The <code>Singleton</code> design pattern makes sure only one instance of an object of a given type is instantiated in a program, and provides a global point of access to it</p>
<ol>
<li>change the access level of the constructor to private</li>
<li>add new public member function <code>Instance()</code> to create the object</li>
<li>use static member variable to hold the object</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrencyFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> CurrencyFactory* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Currency <span class="title">CreateCurrency</span><span class="params">(<span class="keyword">int</span> currencyType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   CurrencyFactory();</span><br><span class="line">   <span class="keyword">static</span> CurrencyFactory* instance_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CurrencyFactory* CurrencyFactory::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance_)</span><br><span class="line">        instance_ = <span class="keyword">new</span> CurrencyFactory;</span><br><span class="line">    <span class="keyword">return</span> instance_; <span class="comment">// no more than one CurrencyFactory object.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Currency CurrencyFactory::CreateCurrency(<span class="keyword">int</span> currencyType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(currencyType)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> EUR:</span><br><span class="line">         <span class="keyword">return</span> Currency(<span class="string">"EUR"</span>, <span class="number">0.7901</span>);</span><br><span class="line">      <span class="keyword">case</span> GBP:</span><br><span class="line">         <span class="keyword">return</span> Currency(<span class="string">"GBP"</span>, <span class="number">0.6201</span>);</span><br><span class="line">      <span class="keyword">case</span> CAD:</span><br><span class="line">         <span class="keyword">return</span> Currency(<span class="string">"CAD"</span>, <span class="number">1.1150</span>);</span><br><span class="line">      <span class="keyword">case</span> AUD:</span><br><span class="line">         <span class="keyword">return</span> Currency(<span class="string">"AUD"</span>, <span class="number">1.1378</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> Currency(<span class="string">"USD"</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CurrencyFactory.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter amount in USD:"</span>;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; amount;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter currency to convert to (ECU/GBP/CHF/JPY): "</span>;</span><br><span class="line">    <span class="built_in">string</span> symbol;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; symbol;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> convertedAmount = <span class="number">0.0</span>;</span><br><span class="line">    Currency currency = CurrencyFactory::Instance()-&gt;CreateCurrency(symbol);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; currency.ConvertFromUSD(amount) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>Classes related by <code>inheritance</code> form a hierachy consisting of base and derived classes. The <code>derived</code> class inherit some members from the base class subject to protection level restrictions, and may extend/override implementation of member functions in the base class.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> name_;</span><br><span class="line">    <span class="built_in">string</span> address_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> school_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><img src="cpp-review-Screen Shot 2019-05-09 at 2.34.31 PM.png" height="300"><br></p>
<h2 id="Virtual"><a href="#Virtual" class="headerlink" title="Virtual"></a>Virtual</h2><p>Different derived classes may inplement member functions from the base class differently. The base class uses <code>virtual</code> keyword to indicate a member function that may be specialized by derived classes.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span></span>; <span class="comment">// specializes Method1()</span></span><br><span class="line">    <span class="comment">// uses default implementation of Method2()</span></span><br><span class="line">    <span class="comment">// can NOT specialize Method3()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Abstract-Class"><a href="#Abstract-Class" class="headerlink" title="Abstract Class"></a>Abstract Class</h2><p>The base class <code>has to</code> either provide a default implementation for that function or declare it <code>pure virtual</code>. If a class has one or more pure virtual function, it is called an <code>abstract class</code> or <code>interface</code>. An abstract class cannot be instantiated.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// this derived is also an abstract</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Virtual-Destructor"><a href="#Virtual-Destructor" class="headerlink" title="Virtual Destructor"></a>Virtual Destructor</h2><p>When we delete a derived class we should execute both the derived class destructor and the base class destructor. A <code>virtual base class destructor</code> is needed to make sure the destructors are called properly when a derived class object is <code>deleted through a pointer to a base class</code>.</p>
<p>If we delete a derived class object through a pointer to a base class when the base class destructor is non-virtual, the result is <code>undefined</code>.</p>
<h2 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h2><p>The types related by inheritance are known as <code>polymorphic</code>. types. We can use polymorphic types interchangeably.</p>
<p>We can use a <code>pointer</code> or a <code>reference</code> to a base class object to point to an object of a derived class – this is known as the <code>Liskov Substitution Principle</code> (LSP). This allows us to write code without needing to know the dynamic type of an object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BankAccount* acc1 = <span class="keyword">new</span> Savings();</span><br><span class="line">acc1-&gt;ApplyInterest(); <span class="comment">// ApplyInterest() on the Savings object</span></span><br><span class="line"></span><br><span class="line">BankAccount* acc2 = <span class="keyword">new</span> Checking();</span><br><span class="line">acc2-&gt;ApplyInterest(); <span class="comment">// ApplyInterest() on the Checking object</span></span><br></pre></td></tr></table></figure>
<p>We can write one function which applies to all account types.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateAccount</span><span class="params">(BankAccount* acc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acc-&gt;ApplyBankingFees();</span><br><span class="line">    acc-&gt;ApplyInterest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateAccount</span><span class="params">(BankAccount&amp; acc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acc.ApplyBankingFees();</span><br><span class="line">    acc.ApplyInterest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Standard-Template-Library-STL"><a href="#Standard-Template-Library-STL" class="headerlink" title="Standard Template Library (STL)"></a>Standard Template Library (STL)</h1><h2 id="Sequential-Container"><a href="#Sequential-Container" class="headerlink" title="Sequential Container"></a>Sequential Container</h2><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><p>The STL array class from offers a more efficient and reliable alternative for C-style arrays, where size is known and we do not have to pass size of array as separate parameter.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="built_in">array</span> &lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">a1.front();</span><br><span class="line">a1.back();</span><br><span class="line">a1.size();</span><br><span class="line">a1.at(<span class="number">1</span>);</span><br><span class="line">get&lt;<span class="number">1</span>&gt;(a1);</span><br></pre></td></tr></table></figure></p>
<h3 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h3><p>Vectors are the stored contiguously same as <em>dynamic arrays</em> with the ability to resize itself automatically when an element is inserted or deleted. Vector size is double whenever half is reached.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">v1.begin();</span><br><span class="line">v1.end();</span><br><span class="line">v1.size();</span><br><span class="line"></span><br><span class="line">v1.push_back(); <span class="comment">// pushes the elements into a vector from the back</span></span><br><span class="line">v1.pop_back(); <span class="comment">// removes the elements from a vector from the back.</span></span><br><span class="line"></span><br><span class="line">v1.insert(i); <span class="comment">// inserts new elements before the element at the specified position</span></span><br><span class="line">v1.assign(i); <span class="comment">// assigns new value to the vector elements by replacing old ones</span></span><br><span class="line">v1.erase(i); <span class="comment">// removes elements from a container from the specified position or range</span></span><br></pre></td></tr></table></figure></p>
<h3 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h3><p>Different from arrays and vectors, A <strong><em>list</em></strong> is  a sequential container that allows non-contiguous memory allocation.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    l1.front(); <span class="comment">// returns the value of the first element</span></span><br><span class="line">    l1.back(); <span class="comment">// returns the value of the last element</span></span><br><span class="line"></span><br><span class="line">    l1.push_front(i); <span class="comment">// adds a new element ‘i’ at the beginning of the list</span></span><br><span class="line">    l1.push_back(i); <span class="comment">// adds a new element ‘i’ at the back of the list</span></span><br><span class="line"></span><br><span class="line">    l1.pop_front(); <span class="comment">// removes the first element and reduces list size by 1</span></span><br><span class="line">    l1.pop_back(); <span class="comment">// removes the last element and reduces list size by 1</span></span><br><span class="line"></span><br><span class="line">    l1.begin(); <span class="comment">// returns an iterator pointing to the first element of the list</span></span><br><span class="line">    l1.end(); <span class="comment">// returns an iterator pointing to the last element of the list    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>The STL string class stores the characters as a sequence of bytes, allowing access to single byte character. Any string is terminated by a <code>\0</code>, so the string <code>foo</code> actually stores four characters.</p>
<h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>The use <code>sizeof()</code> to return the size of an array in bytes. Use <code>.size()</code> member function to return the number of elements in a STL container.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of a: "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of b: "</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of b: "</span> &lt;&lt; b.size() &lt;&lt; <span class="string">" elements"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The size of a: <span class="number">20</span> bytes</span><br><span class="line">The size of b: <span class="number">24</span> bytes</span><br><span class="line">The size of b: <span class="number">5</span> elements</span><br></pre></td></tr></table></figure>
<h2 id="Associative-Container"><a href="#Associative-Container" class="headerlink" title="Associative Container"></a>Associative Container</h2><h3 id="std-set"><a href="#std-set" class="headerlink" title="std::set"></a>std::set</h3><p>Sets are an associative container where each element is unique. The value of the element cannot be modified once it is added to the set.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s1.begin();</span><br><span class="line">    s1.end();</span><br><span class="line">    s1.size();</span><br><span class="line"></span><br><span class="line">    s1.insert(i);</span><br><span class="line">    s1.erase(i);</span><br><span class="line">    s1.find(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h3><p>A <code>std::map</code> sorts its elements by the keys.</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>The STL provides implementations of some widely used algorithms.</p>
<ul>
<li>&lt;<strong><em>algorithms</em></strong>&gt; <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm?view=vs-2019" target="_blank" rel="noopener">header</a>: sorting, searching, copying, modifying elements</li>
<li>&lt;<strong><em>numeric</em></strong>&gt; <a href="http://www.cplusplus.com/reference/numeric/" target="_blank" rel="noopener">header</a>: numeric operation</li>
</ul>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//sort takes a range</span></span><br><span class="line">    sort(values.begin(), values.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//binary_search takes a range and a value</span></span><br><span class="line">    <span class="keyword">bool</span> found = binary_search(values.begin(), values.end(), <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values1&#123; <span class="number">10</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="comment">//destination</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; values2;</span><br><span class="line">    copy(values1.begin(), values1.end(),  <span class="comment">//input range</span></span><br><span class="line">        back_inserter(values2));         <span class="comment">//output iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">10</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    replace(values.begin(), values.end(),  <span class="comment">//range</span></span><br><span class="line">            <span class="number">1</span>,                             <span class="comment">//old value</span></span><br><span class="line">            <span class="number">111</span>);                          <span class="comment">//new value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Numeric"><a href="#Numeric" class="headerlink" title="Numeric"></a>Numeric</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> r1 = accumulate(v1.begin(), v1.end(), <span class="number">0</span>);  <span class="comment">//range</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r2 = inner_product(v1.begin(), v1.end(),</span><br><span class="line">                           v2.begin(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Complexity-Comparison"><a href="#Complexity-Comparison" class="headerlink" title="Complexity Comparison"></a>Complexity Comparison</h3><p><img src="cpp-review-complexity.png" alt="complexity.png"></p>
<h2 id="Smart-Pointer"><a href="#Smart-Pointer" class="headerlink" title="Smart Pointer"></a>Smart Pointer</h2><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>A <code>unique pointer</code> takes unique ownership in its pointed <code>object</code>. The unique pointer delete the object they managed either when the unique pointer is destroyed or when the object’s value changes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Option&gt; sp(<span class="keyword">new</span> Option());</span><br><span class="line"><span class="comment">// initates a smart pointer (or through reset: sp.resert(Option()).)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Option&gt; sp2(sp);</span><br><span class="line"><span class="comment">// error: does not allow two reference (sp, sp2) to the same object (new Option());</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Option&gt; sp2(<span class="built_in">std</span>::move(sp));</span><br><span class="line"><span class="comment">// now sp is destroyed and sp2 takes ownership of the Option object</span></span><br><span class="line"></span><br><span class="line">sp2-&gt;getPrice();</span><br><span class="line"><span class="comment">// smart pointer can be used as regular pointer</span></span><br></pre></td></tr></table></figure>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p>The <code>shared pointer</code> counts the reference to its pointed object and can store and pass a reference beyond the scope of a function. In OOP, the share pointer is used to store a pointer as a member variable and can be used to reference value outside the scope of the class.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::share_ptr&lt;Option&gt; sp2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::share_ptr&lt;Option&gt; sp(<span class="keyword">new</span> Option());</span><br><span class="line">    sp2=sp;</span><br><span class="line">&#125;</span><br><span class="line">sp2-&gt;getPrice();</span><br><span class="line"><span class="comment">// the Option object is not deleted after local scope ends</span></span><br></pre></td></tr></table></figure>
<p>Creating a vector of shared_ptr:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Option&gt;&gt; option_list;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    option_list.push_back(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Option&gt;(<span class="keyword">new</span> Option(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><p>A <code>weak_ptr</code> works the same as <code>shared pointer</code>, but will not increment the reference count.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Option&gt; sp2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::share_ptr&lt;Option&gt; sp(<span class="keyword">new</span> Option());</span><br><span class="line">    sp2=sp;</span><br><span class="line">&#125;</span><br><span class="line">sp2-&gt;getPrice(); <span class="comment">// error! the Option object does not exist beyond scope.</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Parallel-Processing"><a href="#Parallel-Processing" class="headerlink" title="Parallel Processing"></a>Parallel Processing</h1><h2 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h2><p>A <code>thread</code> is a small sequence of programmed instruction and is usually a component of a <code>process</code>. <code>Multi-threading</code> can exist within one process, executing <code>concurrently</code> and share resources such as memory, while processes do not share their resources.</p>
<p>The <code>std::thread</code> class in c++ supports multi-threading, and can be initiated to represent a single thread. We need to pass a callable object (function pointer, function, or lambda) to the constructor of the std::thread class. We use the <code>std::thread.join()</code> method to wait for the copmletion of a thread.</p>
<p>Here we initiate two threads. Both threads share memory and attempt to modify the <code>balance</code> variable at the same time which lead to concurrency issue.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t1 starts</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([&amp;balance] &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;balance++;&#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t2 starts</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([&amp;balance] &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;balance--;&#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join(); <span class="comment">// the main() waits here until t1 completes</span></span><br><span class="line">    t2.join(); <span class="comment">// the main() waits here until t2 completes</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; balance &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"END OF CODE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">153258</span></span><br><span class="line">END OF CODE</span><br></pre></td></tr></table></figure>
<p>We introduce the an <code>mutex</code>, or mutual exclusive, object, which contains a unique id for the resources allocated to the program. A thread can <code>lock</code> the resource by a <code>std::mutex.lock()</code> method, which prevent other thread from sharing the resource until the mutex becomes unlocked.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">    mutex m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t1 starts</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([&amp;balance, &amp;m] &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        m.lock();</span></span></span><br><span class="line"><span class="function"><span class="params">        balance++;</span></span></span><br><span class="line"><span class="function"><span class="params">        m.unlock();</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t2 starts</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([&amp;balance, &amp;m] &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        m.lock();</span></span></span><br><span class="line"><span class="function"><span class="params">        balance--;</span></span></span><br><span class="line"><span class="function"><span class="params">        m.unlock();</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join(); <span class="comment">// the main() waits here until t1 completes</span></span><br><span class="line">    t2.join(); <span class="comment">// the main() waits here until t2 completes</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; balance &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"END OF CODE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">END OF CODE</span><br></pre></td></tr></table></figure>
<h2 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h2><p>A <code>condition variable</code> is an object that can block the calling thread until notified to resume. It uses a <code>unique_lock</code> (over a <code>mutex</code>) to lock the thread when one of its <code>wait</code> functions is called.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex m;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m); <span class="comment">// own the mutex</span></span><br><span class="line">    cv.wait(lk, []&#123;<span class="keyword">return</span> ready;&#125;); <span class="comment">// wait until main() sends data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">        v.push_back(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    lk.unlock(); <span class="comment">// manual unlocking is done before notifying</span></span><br><span class="line">    cv.notify_one();</span><br><span class="line">    <span class="comment">// unblocks one of the threads currently waiting for this condition</span></span><br><span class="line">    <span class="comment">// if no threads are waiting, the function does nothing</span></span><br><span class="line">    <span class="comment">// if more than one threads are waiting, it is unspecified which will be selected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(make_vector)</span></span>;</span><br><span class="line"></span><br><span class="line">    ready = <span class="literal">false</span>;</span><br><span class="line">    processed = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() signals ready for processing\n"</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_one();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m); <span class="comment">// own the mutex</span></span><br><span class="line">        cv.wait(lk, []&#123;<span class="keyword">return</span> processed;&#125;); <span class="comment">// wait for cv.notify_one</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"back to main(), vector is processed\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() signals ready <span class="keyword">for</span> processing</span><br><span class="line">back to main(), vector is processed</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<p>Reference:</p>
<ul>
<li>FINM 322 Lecture Notes, Chanaka Liyanaarachchi, the University of Chicago</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/04/islr/" class="prev">PREV</a><a href="/2019/04/peru-bolivia/" class="next">NEXT</a></div><div id="container"></div><!-- link(rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css")--><link rel="stylesheet" href="/css/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
    clientID: '4ec287ddd4ac34ff5087',
    clientSecret: 'ae45426765f12ac3e2f903662b8938dc4881f703',
    repo: 'jackliu234.github.io',
    owner: 'jackliu234',
    admin: ['jackliu234'],
    perPage: 100,
    id: 'Sat Apr 06 2019 00:00:00 GMT-0500 GMT'.split('GMT')[0].replace(/\s/g, '-'),
    distractionFreeMode: false,
    pagerDirection: 'first'
})

gitalk.render('container')</script><!-- block copyright--></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-133275176-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>