<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Notes on Algorithm, MIT Open Course · Rongjia Liu</title><meta name="description" content="Notes on Algorithm, MIT Open Course - Rongjia Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/arctic.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jackliu234.com/atom.xml" title="Rongjia Liu"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archive/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><!-- li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") <i class="fa fa-search" aria-hidden="true"></i>--></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Notes on Algorithm, MIT Open Course</h1><div class="post-info">Apr 3, 2019<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/tags/Tech/" class="post-tags">#Tech</a></div><div class="post-content"><a id="more"></a>
<h1 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h1><p>Define <script type="math/tex">T(n)</script> as the <em>worst case</em> running time for input size n</p>
<ol>
<li><strong><em>Upper Bound</em></strong> we say <script type="math/tex">T(n)</script> is <script type="math/tex">O(g(n))</script> if <script type="math/tex">0\leq T(n)\leq c_1g(n)</script>, for some <script type="math/tex">c_1</script>.</li>
<li><strong><em>Lower Bound</em></strong> we say <script type="math/tex">T(n)</script> is <script type="math/tex">\Omega (g(n))</script> if <script type="math/tex">0\leq c_2g(n)\leq T(n)</script>, for some <script type="math/tex">c_2</script>.</li>
<li><strong><em>Order</em></strong>: we say <script type="math/tex">T(n)</script> si <script type="math/tex">\Theta(g(n))</script> iff <script type="math/tex">T(n)</script> is <script type="math/tex">O(g(n))</script> and  <script type="math/tex">\Omega (g(n))</script>.</li>
</ol>
<h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>Binary search is a <script type="math/tex">O(logn)</script> algorithm that finds the target value from a sorted array by comparing recursively with the middle elements.</p>
<p>Given input size <script type="math/tex">n=1024</script>, the worst-case time of the search is:</p>
<script type="math/tex; mode=display">T(n) =\log_{2}1024 = \dfrac{log_e1024}{log_e2} = O(logn)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, start, end, element)</span>:</span></span><br><span class="line">    mid = (start + end) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        print(<span class="string">"Element not found"</span>)</span><br><span class="line">    <span class="keyword">elif</span> element &gt; arr[mid]:</span><br><span class="line">        binarySearch(arr, mid + <span class="number">1</span>, end, element)</span><br><span class="line">    <span class="keyword">elif</span> element &lt; arr[mid]:</span><br><span class="line">        binarySearch(arr, start, mid - <span class="number">1</span>, element)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Element is found at index"</span>, str(mid))</span><br></pre></td></tr></table></figure>
<p>Or simply use the <code>binary_search</code> function in the C++ STL <algorithm>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> found = binary_search(values.begin(), values.end(), <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></algorithm></p>
<h2 id="Binary-Search-Tree-BST"><a href="#Binary-Search-Tree-BST" class="headerlink" title="Binary Search Tree (BST)"></a>Binary Search Tree (BST)</h2><p>BST keeps their keys in sorted order, so that looking up values can use the principle of binary search. When looking for a key in a tree (or a place to insert a new key), the comparison traverse the tree from root to leaf, therefore each comparison allows the operations to skip about half of the tree.</p>
<p>BST supports insert, min, delete, and rank operations in <script type="math/tex">O(h)</script> time, where h is the height of the tree taking values between <script type="math/tex">log(n)</script> and <script type="math/tex">n</script>.</p>
<ul>
<li>Faster than the linear time required to find items by key in an <strong>unsorted array</strong>.</li>
<li>Slower than the <strong>hash tables</strong>.</li>
</ul>
<p><strong>Balanced BST</strong> maintains <script type="math/tex">h = log(n)</script>. For example, AVL trees are balanced BST which stores and requires heights of left and right children of every node to differ by at most <script type="math/tex">\pm1</script>. It contains inherently a data structure augmentation procedure.</p>
<h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p>Insertion sort is a <script type="math/tex">O(n^2)</script> sorting algorithm that builds the final sorted array in-place one item at a time:</p>
<ol>
<li>iterate up the array</li>
<li>remove one element from the input data</li>
<li>find the location it belongs within the sorted list</li>
<li>insert it there</li>
</ol>
<h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p>Selection sort is a <script type="math/tex">O(n^2)</script> sorting algorithm.</p>
<ol>
<li>divide the input list into two parts: sorted (empty initially) and unsorted (input array).</li>
<li>find the smallest element in the unsorted sublist</li>
<li>exchange it with the leftmost unsorted element</li>
<li>move the sublist boundaries one element to the right.</li>
</ol>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p>Quick sort is a average <script type="math/tex">O(nlogn)</script> sorting algorithm.</p>
<ol>
<li>Pick an element, called a pivot, from the array.</li>
<li><strong><em>Partitioning</em></strong> reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position.</li>
<li>Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</li>
</ol>
<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>A heap data structure is a specialized tree-based data structure which is essentially an almost complete tree that satisfies the <strong>heap property</strong>:</p>
<ul>
<li>if P is a parent node of C, then the key (the value) of P is either:<ul>
<li>(in a max heap) greater than or equal to the key of C</li>
<li>(in a min heap) less than or equal to the key of C.</li>
</ul>
</li>
</ul>
<p>Heap sort is an improved selection sort with <script type="math/tex">O(nlogn)</script>, using a <strong>max heap</strong> data structure rather than a linear-time search to find the maximum. It is invented by J. W. J. Williams in 1964.</p>
<ul>
<li>Heap sort is slower in practice than a well-implemented quicks ort, despite having a more favorable worst-case <script type="math/tex">O(nlogn)</script> compared to the <script type="math/tex">O(n^2)</script> of quick sort.</li>
</ul>
<h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><p>Merge sort is a <script type="math/tex">O(nlogn)</script> algorithm that uses a divide/conquer/combine paradigm to scale down the complexity and scale up the efficiency of the Insertion Sort routine. It is invented by <strong>John von Neumann</strong> in 1945.</p>
<p>With merge sort the running time scales “nearly linearly” with <script type="math/tex">O(nlogn)</script>:</p>
<script type="math/tex; mode=display">\begin{align}
T(n) &= \underset{divide}{C} + \underset{recursion}{2T(n/2)} + \underset{merge}{Cn} \\
&= \Theta(nlogn)
\end{align}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Sort list A into order, and return result.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line">    mid = n//<span class="number">2</span>     <span class="comment"># floor division</span></span><br><span class="line">    L = merge_sort(A[:mid])</span><br><span class="line">    R = merge_sort(A[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(L,R)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(L,R)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Given two sorted sequences L and R, return their merge.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    answer = []</span><br><span class="line">    <span class="keyword">while</span> i&lt;len(L) <span class="keyword">and</span> j&lt;len(R):</span><br><span class="line">        <span class="keyword">if</span> L[i]&lt;R[j]:</span><br><span class="line">            answer.append(L[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer.append(R[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;len(L):</span><br><span class="line">        answer.extend(L[i:])</span><br><span class="line">    <span class="keyword">if</span> j&lt;len(R):</span><br><span class="line">        answer.extend(R[j:])</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<p>Reference:</p>
<ul>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/index.htm" target="_blank" rel="noopener">Introduction To Algorithm</a>, MIT Open Course</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/04/cpp/" class="prev">PREV</a><a href="/2019/04/peru-bolivia/" class="next">NEXT</a></div><div id="container"></div><!-- link(rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css")--><link rel="stylesheet" href="/css/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
    clientID: '4ec287ddd4ac34ff5087',
    clientSecret: 'ae45426765f12ac3e2f903662b8938dc4881f703',
    repo: 'jackliu234.github.io',
    owner: 'jackliu234',
    admin: ['jackliu234'],
    perPage: 100,
    id: 'Wed Apr 03 2019 00:00:00 GMT+0200 GMT'.split('GMT')[0].replace(/\s/g, '-'),
    distractionFreeMode: false,
    pagerDirection: 'first'
})

gitalk.render('container')</script><!-- block copyright--></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-133275176-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>