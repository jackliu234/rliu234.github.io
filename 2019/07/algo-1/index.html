<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Bitcoin Quant Strategies with Backtesting Results · Rongjia Liu</title><meta name="description" content="Bitcoin Quant Strategies with Backtesting Results - Rongjia Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/arctic.css"><link rel="search" type="application/opensearchdescription+xml" href="http://rliu6.com/atom.xml" title="Rongjia Liu"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><!-- li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") <i class="fa fa-search" aria-hidden="true"></i>--></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Bitcoin Quant Strategies with Backtesting Results</h1><div class="post-info"><!-- if is_post()--><!--     span &#128197; &nbsp;-->Jul 20, 2019<!-- if is_post()--><!--    span#busuanzi_container_page_pv | &#128065;--><!--    span#busuanzi_value_page_pv--><!--    if item.tags--><!--        span | &nbsp;--><!--        for tag in item.tags.toArray()--><!--            a(href=url_for(tag.path))=  '#' + tag.name--><!-- if item.from && (is_home() || is_post())--><!--    a.post-from(href=item.from target="_blank" title=item.from)!= __('translated')-->
</div><div class="post-content"><h1 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a><span id="nav">Navigation</span></h1><p><a href="#01">01. Classification Methods</a><br><a href="#02">02. Momemtum</a><br><a href="#03">03. Perpectual Swap Funding</a></p>
<p><br></p>
<h1 id="128214-Classification-Methods-8634"><a href="#128214-Classification-Methods-8634" class="headerlink" title="&#128214; Classification Methods &#8634;"></a><span id="01">&#128214; Classification Methods</span> <sup><a href="#nav">&#8634;</a></sup></h1><p>In this research I looked at intraday Bitcoin trading based on price and volume information using classification models.</p>
<table>
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>Strategy</th>
      <th>Precision</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>10</th>
      <td>MLP Classifier</td>
      <td>0.55</td>
      <td>2.06</td>
      <td>1.79</td>
    </tr>
    <tr>
      <th>3</th>
      <td>KNN</td>
      <td>0.50</td>
      <td>1.95</td>
      <td>1.85</td>
    </tr>
    <tr>
      <th>0</th>
      <td>Baseline</td>
      <td>0.00</td>
      <td>1.69</td>
      <td>1.14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Decision Tree</td>
      <td>0.49</td>
      <td>1.61</td>
      <td>1.84</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Random Forest</td>
      <td>0.53</td>
      <td>1.55</td>
      <td>1.16</td>
    </tr>
    <tr>
      <th>8</th>
      <td>XGBoost</td>
      <td>0.52</td>
      <td>1.33</td>
      <td>0.86</td>
    </tr>
    <tr>
      <th>9</th>
      <td>SVC</td>
      <td>0.47</td>
      <td>1.31</td>
      <td>0.73</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Logistic Regression</td>
      <td>0.47</td>
      <td>1.14</td>
      <td>0.47</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Gradient Boost</td>
      <td>0.48</td>
      <td>1.06</td>
      <td>0.33</td>
    </tr>
    <tr>
      <th>6</th>
      <td>AdaBoost</td>
      <td>0.50</td>
      <td>0.86</td>
      <td>-0.09</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Linear Discriminant Analysis</td>
      <td>0.47</td>
      <td>0.85</td>
      <td>-0.17</td>
    </tr>
  </tbody>
</table>

<a id="more"></a>
<h1 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> set_start_method</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, HTML, Image</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold, GridSearchCV</span><br><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span> register_matplotlib_converters</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier</span><br><span class="line"></span><br><span class="line">register_matplotlib_converters()</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = <span class="string">"serif"</span></span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>] = <span class="string">"DejaVu Serif"</span></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">12</span>, <span class="number">6</span>)</span><br><span class="line">plt.rcParams[<span class="string">'figure.dpi'</span>] = <span class="number">100</span></span><br><span class="line">plt.rcParams[<span class="string">'lines.linewidth'</span>] = <span class="number">0.75</span></span><br><span class="line">pd.set_option(<span class="string">'max_row'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>This is a customized function used to plot confusion matrix in python.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp</span><span class="params">(df, max_rows=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> display(HTML(df.to_html(max_rows=max_rows, header=<span class="keyword">True</span>).replace(<span class="string">'&lt;table border="1" class="dataframe"&gt;'</span>,<span class="string">'&lt;table&gt;'</span>)))</span><br></pre></td></tr></table></figure>
<h1 id="Data-Exploration"><a href="#Data-Exploration" class="headerlink" title="Data Exploration"></a>Data Exploration</h1><p>I got the preliminary bitcoin data from <a href="https://api.bitcoincharts.com/v1/csv/" target="_blank" rel="noopener">bitcoincharts</a>. Data include price and volume information recorded by Bitstamp and split by seconds. This provide great granularity that can be grouped into any desirable levels later on.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'bitstampUSD.csv'</span>, header=<span class="keyword">None</span>, names=[<span class="string">'time'</span>, <span class="string">'price'</span>, <span class="string">'volume'</span>])</span><br><span class="line">data[<span class="string">'time'</span>] = pd.to_datetime(data[<span class="string">'time'</span>], unit=<span class="string">'s'</span>)</span><br><span class="line">data.set_index(<span class="string">'time'</span>, inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>Get 3-month treasury bill price.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'https://fred.stlouisfed.org/graph/fredgraph.csv?id=DTB3'</span></span><br><span class="line">tr  = pd.read_csv(url, index_col=<span class="number">0</span>, parse_dates=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>We first resample our data by hour. Since most Bitcoin exchanges nowadays have transaction fees, which renders retail trading at a high frequency level unattainable. Therefore I leave out the second and minute level data and combine them into hours. Note that I average the price while summing the volume within an hour.</p>
<p>A 2 year data window from 2017 to 2019 is used, as this is when Bitcoin and other crypto has come into the attention of the larger public, and mostly importantly, started to be heavily traded. Therefore the training set will be more representative of any future trading environment. The plot below illustrates the total dollar amount traded per hours over time.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df0 = data.resample(<span class="string">'H'</span>).agg(&#123;<span class="string">'price'</span>: np.mean, <span class="string">'volume'</span>: np.sum&#125;).fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line">plt.plot(df0.volume * df0.price, c=<span class="string">'black'</span>)</span><br><span class="line">plt.title(<span class="string">'Bitcoin Dollar Volume in Dollar Term'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_14_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1  = data.loc[<span class="string">'2017-07-01'</span>:<span class="string">'2019-06-30'</span>].resample(<span class="string">'H'</span>).agg(&#123;<span class="string">'price'</span>: np.mean,</span><br><span class="line">                                                            <span class="string">'volume'</span>: np.sum&#125;).fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line">df2 = tr.loc[<span class="string">'2017-07-01'</span>:<span class="string">'2019-06-30'</span>]</span><br><span class="line">df = df1.join(df2).replace(<span class="string">'.'</span>, np.NaN).fillna(method=<span class="string">'ffill'</span>).fillna(method=<span class="string">'bfill'</span>).rename(&#123;<span class="string">'DTB3'</span>: <span class="string">'tr'</span>&#125;, axis=<span class="number">1</span>)</span><br><span class="line">df.tr = df.tr.astype(float)/<span class="number">100</span></span><br><span class="line">disp(df)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>volume</th>
      <th>tr</th>
    </tr>
    <tr>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2017-07-01 00:00:00</th>
      <td>2473.427264</td>
      <td>200.793669</td>
      <td>0.0104</td>
    </tr>
    <tr>
      <th>2017-07-01 01:00:00</th>
      <td>2463.946180</td>
      <td>228.853771</td>
      <td>0.0104</td>
    </tr>
    <tr>
      <th>2017-07-01 02:00:00</th>
      <td>2441.314976</td>
      <td>475.068038</td>
      <td>0.0104</td>
    </tr>
    <tr>
      <th>2017-07-01 03:00:00</th>
      <td>2449.063866</td>
      <td>177.876034</td>
      <td>0.0104</td>
    </tr>
    <tr>
      <th>2017-07-01 04:00:00</th>
      <td>2453.192311</td>
      <td>120.916328</td>
      <td>0.0104</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2019-06-30 19:00:00</th>
      <td>11173.875377</td>
      <td>389.958860</td>
      <td>0.0208</td>
    </tr>
    <tr>
      <th>2019-06-30 20:00:00</th>
      <td>11276.492157</td>
      <td>372.471619</td>
      <td>0.0208</td>
    </tr>
    <tr>
      <th>2019-06-30 21:00:00</th>
      <td>11340.807808</td>
      <td>295.522323</td>
      <td>0.0208</td>
    </tr>
    <tr>
      <th>2019-06-30 22:00:00</th>
      <td>11037.539360</td>
      <td>963.543871</td>
      <td>0.0208</td>
    </tr>
    <tr>
      <th>2019-06-30 23:00:00</th>
      <td>10838.165248</td>
      <td>1152.810243</td>
      <td>0.0208</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(df.price, c=<span class="string">'black'</span>)</span><br><span class="line">plt.title(<span class="string">'Bitcoin Price 2017-07-01 to 2019-06-30'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_16_0.png" alt="png"></p>
<p>We then created several more data fields intending to extract more information from the previous n-hour window</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interval = [<span class="number">6</span>, <span class="number">12</span>, <span class="number">24</span>, <span class="number">48</span>, <span class="number">120</span>] <span class="comment"># 0.25, 0.5, 1, 2, 5 days</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> interval:</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> [<span class="string">'price'</span>, <span class="string">'volume'</span>]:</span><br><span class="line">        df[c+<span class="string">'_change_'</span>+str(i)+<span class="string">'H'</span>]   = df[c]/df[c].shift(i)<span class="number">-1</span></span><br><span class="line">        df[c+<span class="string">'_high_'</span>+str(i)+<span class="string">'H'</span>]     = df[c].rolling(i).max().shift(<span class="number">1</span>) / df[c]</span><br><span class="line">        df[c+<span class="string">'_low_'</span>+str(i)+<span class="string">'H'</span>]      = df[c].rolling(i).min().shift(<span class="number">1</span>) / df[c]</span><br><span class="line">        df[c+<span class="string">'_avg_'</span>+str(i)+<span class="string">'H'</span>]      = df[c].rolling(i).mean().shift(<span class="number">1</span>) / df[c]  </span><br><span class="line">        df[c+<span class="string">'_std_'</span>+str(i)+<span class="string">'H'</span>]      = df[c].rolling(i).std().shift(<span class="number">1</span>) / df[c] * np.sqrt(<span class="number">24</span>/i)</span><br><span class="line"></span><br><span class="line">df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">disp(df.head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>volume</th>
      <th>tr</th>
      <th>price_change_6H</th>
      <th>price_high_6H</th>
      <th>price_low_6H</th>
      <th>price_avg_6H</th>
      <th>price_std_6H</th>
      <th>volume_change_6H</th>
      <th>volume_high_6H</th>
      <th>volume_low_6H</th>
      <th>volume_avg_6H</th>
      <th>volume_std_6H</th>
      <th>price_change_12H</th>
      <th>price_high_12H</th>
      <th>price_low_12H</th>
      <th>price_avg_12H</th>
      <th>price_std_12H</th>
      <th>volume_change_12H</th>
      <th>volume_high_12H</th>
      <th>volume_low_12H</th>
      <th>volume_avg_12H</th>
      <th>volume_std_12H</th>
      <th>price_change_24H</th>
      <th>price_high_24H</th>
      <th>price_low_24H</th>
      <th>price_avg_24H</th>
      <th>price_std_24H</th>
      <th>volume_change_24H</th>
      <th>volume_high_24H</th>
      <th>volume_low_24H</th>
      <th>volume_avg_24H</th>
      <th>volume_std_24H</th>
      <th>price_change_48H</th>
      <th>price_high_48H</th>
      <th>price_low_48H</th>
      <th>price_avg_48H</th>
      <th>price_std_48H</th>
      <th>volume_change_48H</th>
      <th>volume_high_48H</th>
      <th>volume_low_48H</th>
      <th>volume_avg_48H</th>
      <th>volume_std_48H</th>
      <th>price_change_120H</th>
      <th>price_high_120H</th>
      <th>price_low_120H</th>
      <th>price_avg_120H</th>
      <th>price_std_120H</th>
      <th>volume_change_120H</th>
      <th>volume_high_120H</th>
      <th>volume_low_120H</th>
      <th>volume_avg_120H</th>
      <th>volume_std_120H</th>
    </tr>
    <tr>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2017-07-06 00:00:00</th>
      <td>2607.823311</td>
      <td>233.619901</td>
      <td>0.0102</td>
      <td>0.005149</td>
      <td>1.001294</td>
      <td>0.994877</td>
      <td>0.998116</td>
      <td>0.005057</td>
      <td>-0.539692</td>
      <td>2.172459</td>
      <td>1.271991</td>
      <td>1.710225</td>
      <td>0.606196</td>
      <td>0.019447</td>
      <td>1.001294</td>
      <td>0.980924</td>
      <td>0.991722</td>
      <td>0.010182</td>
      <td>-0.137448</td>
      <td>2.604881</td>
      <td>0.986408</td>
      <td>1.724699</td>
      <td>0.659083</td>
      <td>0.012479</td>
      <td>1.001294</td>
      <td>0.973805</td>
      <td>0.985347</td>
      <td>0.008630</td>
      <td>-0.708220</td>
      <td>3.444264</td>
      <td>0.815879</td>
      <td>1.940980</td>
      <td>0.748083</td>
      <td>0.019561</td>
      <td>1.008966</td>
      <td>0.973805</td>
      <td>0.990540</td>
      <td>0.006865</td>
      <td>0.552344</td>
      <td>4.357035</td>
      <td>0.644187</td>
      <td>1.832178</td>
      <td>0.620839</td>
      <td>0.054336</td>
      <td>1.008966</td>
      <td>0.916032</td>
      <td>0.966001</td>
      <td>0.011353</td>
      <td>0.163482</td>
      <td>8.713623</td>
      <td>0.498690</td>
      <td>1.772706</td>
      <td>0.491582</td>
    </tr>
    <tr>
      <th>2017-07-06 01:00:00</th>
      <td>2592.974565</td>
      <td>229.561261</td>
      <td>0.0102</td>
      <td>-0.005044</td>
      <td>1.007028</td>
      <td>1.001879</td>
      <td>1.004691</td>
      <td>0.004088</td>
      <td>-0.415935</td>
      <td>1.872772</td>
      <td>1.017680</td>
      <td>1.541597</td>
      <td>0.657009</td>
      <td>0.011195</td>
      <td>1.007028</td>
      <td>0.988929</td>
      <td>0.999000</td>
      <td>0.009511</td>
      <td>-0.622775</td>
      <td>2.650935</td>
      <td>1.003848</td>
      <td>1.741677</td>
      <td>0.698711</td>
      <td>0.011259</td>
      <td>1.007028</td>
      <td>0.979381</td>
      <td>0.991506</td>
      <td>0.009179</td>
      <td>-0.707043</td>
      <td>3.505159</td>
      <td>0.830303</td>
      <td>1.872374</td>
      <td>0.713401</td>
      <td>0.009083</td>
      <td>1.014744</td>
      <td>0.979381</td>
      <td>0.996615</td>
      <td>0.006895</td>
      <td>0.168152</td>
      <td>4.434067</td>
      <td>0.830303</td>
      <td>1.872115</td>
      <td>0.625493</td>
      <td>0.052367</td>
      <td>1.014744</td>
      <td>0.921278</td>
      <td>0.971965</td>
      <td>0.011479</td>
      <td>0.003091</td>
      <td>8.867680</td>
      <td>0.507507</td>
      <td>1.805239</td>
      <td>0.499861</td>
    </tr>
    <tr>
      <th>2017-07-06 02:00:00</th>
      <td>2595.240970</td>
      <td>111.498601</td>
      <td>0.0102</td>
      <td>-0.005029</td>
      <td>1.006148</td>
      <td>0.999127</td>
      <td>1.002969</td>
      <td>0.005542</td>
      <td>-0.624789</td>
      <td>3.855797</td>
      <td>2.058871</td>
      <td>2.929583</td>
      <td>1.561810</td>
      <td>0.009963</td>
      <td>1.006148</td>
      <td>0.989687</td>
      <td>0.999049</td>
      <td>0.008379</td>
      <td>-0.765640</td>
      <td>4.551893</td>
      <td>2.058871</td>
      <td>3.302634</td>
      <td>1.296594</td>
      <td>0.016319</td>
      <td>1.006148</td>
      <td>0.978526</td>
      <td>0.991104</td>
      <td>0.009312</td>
      <td>-0.861432</td>
      <td>7.216670</td>
      <td>1.709488</td>
      <td>3.647934</td>
      <td>1.347291</td>
      <td>0.000808</td>
      <td>1.013858</td>
      <td>0.978526</td>
      <td>0.995932</td>
      <td>0.006872</td>
      <td>-0.870219</td>
      <td>9.129174</td>
      <td>1.709488</td>
      <td>3.860618</td>
      <td>1.283035</td>
      <td>0.063050</td>
      <td>1.013858</td>
      <td>0.920474</td>
      <td>0.971530</td>
      <td>0.011491</td>
      <td>-0.765300</td>
      <td>18.257410</td>
      <td>1.044891</td>
      <td>3.716808</td>
      <td>1.029132</td>
    </tr>
    <tr>
      <th>2017-07-06 03:00:00</th>
      <td>2601.939179</td>
      <td>154.465403</td>
      <td>0.0102</td>
      <td>0.001575</td>
      <td>1.003558</td>
      <td>0.996555</td>
      <td>0.999547</td>
      <td>0.005543</td>
      <td>-0.640708</td>
      <td>2.783251</td>
      <td>0.721835</td>
      <td>1.914348</td>
      <td>1.612821</td>
      <td>0.013029</td>
      <td>1.003558</td>
      <td>0.987139</td>
      <td>0.997297</td>
      <td>0.007360</td>
      <td>-0.329707</td>
      <td>3.285718</td>
      <td>0.721835</td>
      <td>2.187443</td>
      <td>1.098140</td>
      <td>0.017659</td>
      <td>1.003558</td>
      <td>0.976007</td>
      <td>0.989220</td>
      <td>0.009328</td>
      <td>-0.719538</td>
      <td>4.131480</td>
      <td>0.721835</td>
      <td>2.446232</td>
      <td>0.882973</td>
      <td>-0.004151</td>
      <td>1.011248</td>
      <td>0.976007</td>
      <td>0.993385</td>
      <td>0.006859</td>
      <td>-0.848249</td>
      <td>6.589761</td>
      <td>0.721835</td>
      <td>2.685895</td>
      <td>0.903309</td>
      <td>0.062422</td>
      <td>1.011248</td>
      <td>0.918104</td>
      <td>0.969522</td>
      <td>0.011449</td>
      <td>-0.131612</td>
      <td>13.178846</td>
      <td>0.721835</td>
      <td>2.663309</td>
      <td>0.746976</td>
    </tr>
    <tr>
      <th>2017-07-06 04:00:00</th>
      <td>2594.198903</td>
      <td>323.934946</td>
      <td>0.0102</td>
      <td>-0.006510</td>
      <td>1.006553</td>
      <td>0.999528</td>
      <td>1.002792</td>
      <td>0.005453</td>
      <td>-0.093037</td>
      <td>1.273228</td>
      <td>0.344201</td>
      <td>0.771118</td>
      <td>0.713993</td>
      <td>0.006701</td>
      <td>1.006553</td>
      <td>0.993343</td>
      <td>1.001348</td>
      <td>0.005868</td>
      <td>-0.345152</td>
      <td>1.566764</td>
      <td>0.344201</td>
      <td>1.023516</td>
      <td>0.558260</td>
      <td>0.021535</td>
      <td>1.006553</td>
      <td>0.978919</td>
      <td>0.992897</td>
      <td>0.009496</td>
      <td>-0.492401</td>
      <td>1.970058</td>
      <td>0.344201</td>
      <td>1.115490</td>
      <td>0.427613</td>
      <td>-0.005803</td>
      <td>1.014265</td>
      <td>0.978919</td>
      <td>0.996261</td>
      <td>0.006822</td>
      <td>0.102404</td>
      <td>2.598252</td>
      <td>0.344201</td>
      <td>1.225214</td>
      <td>0.392388</td>
      <td>0.057479</td>
      <td>1.014265</td>
      <td>0.920843</td>
      <td>0.972906</td>
      <td>0.011490</td>
      <td>1.679001</td>
      <td>6.284212</td>
      <td>0.344201</td>
      <td>1.269372</td>
      <td>0.356447</td>
    </tr>
  </tbody>
</table>


<h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p>Due to the large number of features created in the last step, we use PCA to reduce the dimensionality of the data. Aside from price, 15 other principal components are retained. Since we mostly care about predicting accuracy, therefore we are okay with losing some interpretability in the PCA process.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = StandardScaler().fit_transform(df.iloc[:, <span class="number">3</span>:])</span><br><span class="line">comp = <span class="number">15</span></span><br><span class="line">pca = PCA(n_components=comp)</span><br><span class="line">X_pca = pca.fit_transform(X)</span><br><span class="line">np.round(pca.explained_variance_ratio_, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.29, 0.23, 0.13, 0.06, 0.05, 0.03, 0.03, 0.02, 0.02, 0.02, 0.01,
       0.01, 0.01, 0.01, 0.01])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.round(np.sum(pca.explained_variance_ratio_), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>0.93
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_pca = pd.DataFrame(X_pca, index=df.index, columns = [<span class="string">'PC'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, comp+<span class="number">1</span>)])</span><br><span class="line">df = pd.DataFrame(df.iloc[:, <span class="number">0</span>:<span class="number">3</span>]).join(df_pca)</span><br><span class="line">disp(df.head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>volume</th>
      <th>tr</th>
      <th>PC1</th>
      <th>PC2</th>
      <th>PC3</th>
      <th>PC4</th>
      <th>PC5</th>
      <th>PC6</th>
      <th>PC7</th>
      <th>PC8</th>
      <th>PC9</th>
      <th>PC10</th>
      <th>PC11</th>
      <th>PC12</th>
      <th>PC13</th>
      <th>PC14</th>
      <th>PC15</th>
    </tr>
    <tr>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2017-07-06 00:00:00</th>
      <td>2607.823311</td>
      <td>233.619901</td>
      <td>0.0102</td>
      <td>1.204847</td>
      <td>-1.442388</td>
      <td>-0.936078</td>
      <td>0.562964</td>
      <td>-1.802252</td>
      <td>-0.126177</td>
      <td>-2.115852</td>
      <td>0.258446</td>
      <td>0.547159</td>
      <td>-0.005956</td>
      <td>-0.345683</td>
      <td>-0.077257</td>
      <td>-0.389290</td>
      <td>-0.253596</td>
      <td>0.501094</td>
    </tr>
    <tr>
      <th>2017-07-06 01:00:00</th>
      <td>2592.974565</td>
      <td>229.561261</td>
      <td>0.0102</td>
      <td>1.072486</td>
      <td>-0.509851</td>
      <td>-1.208146</td>
      <td>1.100969</td>
      <td>-1.991122</td>
      <td>0.106322</td>
      <td>-1.995090</td>
      <td>0.089313</td>
      <td>0.690748</td>
      <td>-0.003055</td>
      <td>-0.152291</td>
      <td>-0.266696</td>
      <td>-0.403753</td>
      <td>-0.415290</td>
      <td>0.602009</td>
    </tr>
    <tr>
      <th>2017-07-06 02:00:00</th>
      <td>2595.240970</td>
      <td>111.498601</td>
      <td>0.0102</td>
      <td>6.313332</td>
      <td>0.286169</td>
      <td>-0.274636</td>
      <td>1.772318</td>
      <td>-3.465762</td>
      <td>0.816421</td>
      <td>-5.245687</td>
      <td>0.737407</td>
      <td>1.652572</td>
      <td>0.043234</td>
      <td>0.118171</td>
      <td>-0.658779</td>
      <td>-0.606447</td>
      <td>-0.557087</td>
      <td>0.499793</td>
    </tr>
    <tr>
      <th>2017-07-06 03:00:00</th>
      <td>2601.939179</td>
      <td>154.465403</td>
      <td>0.0102</td>
      <td>1.986983</td>
      <td>-0.820551</td>
      <td>-1.195466</td>
      <td>0.697308</td>
      <td>-1.574198</td>
      <td>0.289253</td>
      <td>-1.100313</td>
      <td>0.593288</td>
      <td>0.655685</td>
      <td>-0.005791</td>
      <td>-0.018679</td>
      <td>-0.152047</td>
      <td>-0.354950</td>
      <td>-0.493463</td>
      <td>0.640942</td>
    </tr>
    <tr>
      <th>2017-07-06 04:00:00</th>
      <td>2594.198903</td>
      <td>323.934946</td>
      <td>0.0102</td>
      <td>-1.350755</td>
      <td>-0.873287</td>
      <td>-1.805126</td>
      <td>0.663435</td>
      <td>-0.972641</td>
      <td>0.036059</td>
      <td>-0.009574</td>
      <td>0.000981</td>
      <td>0.200082</td>
      <td>0.315963</td>
      <td>-0.225084</td>
      <td>-0.120908</td>
      <td>-0.308701</td>
      <td>-0.390018</td>
      <td>0.597231</td>
    </tr>
  </tbody>
</table>


<h1 id="Modeling"><a href="#Modeling" class="headerlink" title="Modeling"></a>Modeling</h1><p>Train and test sets are created for modeling purpose. Since it is time series data, randomization will not be performed. Rather, both train and test sets are chosen such that they both include a market upturn and market downturn.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train  = df.loc[<span class="string">'2017-07-01'</span>:<span class="string">'2018-06-30'</span>]</span><br><span class="line">test   = df.loc[<span class="string">'2018-07-01'</span>:<span class="string">'2019-06-30'</span>]</span><br></pre></td></tr></table></figure>
<p>Here we specify some modeling parameters. The trading frequency is set to one day.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trade_interval      = <span class="string">'1H'</span></span><br><span class="line">trade_interval_min  = <span class="number">60</span></span><br><span class="line">ann_factor          = <span class="number">24</span> * <span class="number">365</span></span><br><span class="line">training_threshold  = <span class="number">0.0075</span></span><br><span class="line">transaction_fee     = <span class="number">0.0025</span></span><br></pre></td></tr></table></figure>
<p>Create a model engine that fit the train data and use grid search CV to tune the parameter grid. A long trade will be executed only if the model predict a next-5-day up move in the last 24 consecutive hours. This limits the frequency of trade which reduce the impact of the relatively large transaction fee per trade. The training threshold is set to 75 bps, which means the model is train to identify a potential up move of more than 75 bps in the next 5 days.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_model</span><span class="params">(Model, model_name, param, param_init, param_grid, search=False)</span>:</span></span><br><span class="line">    <span class="comment"># prepare data</span></span><br><span class="line">    train_copy = train.resample(trade_interval).first()</span><br><span class="line">    test_copy = test.resample(trade_interval).first()</span><br><span class="line">    train_copy.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    test_copy.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    indicator = <span class="number">24</span>  <span class="comment"># hr</span></span><br><span class="line">    offset    = <span class="number">120</span> <span class="comment"># hr</span></span><br><span class="line"></span><br><span class="line">    X_train = train_copy.iloc[:-offset, <span class="number">3</span>:]</span><br><span class="line">    Y_train = (train_copy.price.shift(-offset)/train_copy.price)[:-offset] &gt; (<span class="number">1</span> + training_threshold)</span><br><span class="line">    X_test  = test_copy.iloc[:-offset, <span class="number">3</span>:]</span><br><span class="line">    Y_test  = (test_copy.price.shift(-offset)/test_copy.price)[:-offset] &gt; (<span class="number">1</span> + training_threshold)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># run model</span></span><br><span class="line">    <span class="keyword">if</span> search:</span><br><span class="line">        model = GridSearchCV(estimator=Model(**param_init),</span><br><span class="line">                             cv=KFold(n_splits=<span class="number">5</span>, random_state=<span class="number">0</span>),</span><br><span class="line">                             scoring=<span class="string">'precision'</span>,</span><br><span class="line">                             param_grid=param_grid).fit(X_train, Y_train)</span><br><span class="line">        print(<span class="string">f'cv precision: <span class="subst">&#123;round(model.best_score_, <span class="number">2</span>)&#125;</span>, best param: <span class="subst">&#123;model.best_params_&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model = Model(**param).fit(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">    Y_pred    = model.predict(X_test)</span><br><span class="line">    cm        = confusion_matrix(Y_test, Y_pred)</span><br><span class="line">    precision = round(cm[<span class="number">1</span>][<span class="number">1</span>]/(cm[<span class="number">1</span>][<span class="number">1</span>] + cm[<span class="number">0</span>][<span class="number">1</span>]), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calculate pnl</span></span><br><span class="line">    <span class="comment"># test_copy['ind']     = np.append(Y_pred, False)</span></span><br><span class="line">    <span class="comment"># test_copy['pnl']     = test_copy.ind * (test_copy.price.shift(-1) / test_copy.price)</span></span><br><span class="line">    test_copy[<span class="string">'pred'</span>] = np.append(Y_pred, [<span class="keyword">False</span>] * offset)</span><br><span class="line">    test_copy[<span class="string">'ind'</span>]  = test_copy.pred.rolling(indicator).sum() == indicator</span><br><span class="line">    test_copy[<span class="string">'buy'</span>]  = test_copy.ind.rolling(offset).sum() &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    test_copy[<span class="string">'pnl'</span>]  = test_copy.buy * (test_copy.price.shift(<span class="number">-1</span>) / test_copy.price)</span><br><span class="line">    test_copy.pnl.replace(<span class="number">0</span>, <span class="number">1</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">    test_copy.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    test_copy[<span class="string">'fee'</span>]  = np.where(test_copy.ind != test_copy.ind.shift(<span class="number">1</span>), <span class="number">1</span>-transaction_fee, <span class="number">1</span>)</span><br><span class="line">    test_copy.pnl     *= test_copy.fee</span><br><span class="line"></span><br><span class="line">    test_pnl  = round(test_copy.pnl.cumprod()[<span class="number">-1</span>], <span class="number">2</span>)</span><br><span class="line">    test_spr  = round(np.mean(test_copy.pnl - <span class="number">1</span> - test_copy.tr/(ann_factor))</span><br><span class="line">                      / (test_copy.pnl - <span class="number">1</span>).std() * np.sqrt(ann_factor), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'test precision: <span class="subst">&#123;precision&#125;</span>; pnl: <span class="subst">&#123;test_pnl&#125;</span>, spr: <span class="subst">&#123;test_spr&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> test_copy.pnl, precision, test_pnl, test_spr</span><br></pre></td></tr></table></figure>
<h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">baseline        = test.resample(trade_interval).first()</span><br><span class="line">baseline[<span class="string">'pnl'</span>] = baseline.price / baseline.price.shift(<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">baseline_pnl    = round(baseline.price.iloc[<span class="number">-1</span>] / baseline.price.iloc[<span class="number">0</span>], <span class="number">2</span>)</span><br><span class="line">baseline_spr    = round(np.mean(baseline.pnl - baseline.tr/(ann_factor))</span><br><span class="line">                        / baseline.pnl.std() * np.sqrt(ann_factor), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">result = test[[<span class="string">'price'</span>]].copy().rename(&#123;<span class="string">'price'</span>: <span class="string">'Baseline'</span>&#125;, axis=<span class="number">1</span>)/test.price.iloc[<span class="number">0</span>]*<span class="number">1000</span></span><br><span class="line">comp = pd.DataFrame(&#123;<span class="string">'Strategy'</span>: <span class="string">'Baseline'</span>, <span class="string">'Precision'</span>: <span class="string">'NA'</span>,</span><br><span class="line">                     <span class="string">'P&amp;L'</span>: baseline_pnl, <span class="string">'Sharpe Ratio'</span>: baseline_spr&#125;, index=[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">f'test precision: <span class="subst">&#123;np.NaN&#125;</span>; pnl: <span class="subst">&#123;baseline_pnl&#125;</span>, spr: <span class="subst">&#123;baseline_spr&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p>test precision: nan; pnl: 1.69, spr: 1.14</p>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Model      = LogisticRegression</span><br><span class="line">model_name = <span class="string">'Logistic Regression'</span></span><br><span class="line">param      = &#123;<span class="string">'class_weight'</span>:<span class="string">'balanced'</span>,</span><br><span class="line">              <span class="string">'solver'</span>:<span class="string">'liblinear'</span>,</span><br><span class="line">              <span class="string">'random_state'</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="string">'C'</span>: <span class="number">0.001</span>,</span><br><span class="line">              <span class="string">'penalty'</span>: <span class="string">'l2'</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'class_weight'</span>: <span class="string">'balanced'</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>], <span class="string">'penalty'</span>: [<span class="string">'l1'</span>, <span class="string">'l2'</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.52, best param: {‘C’: 0.01, ‘penalty’: ‘l1’}<br>test precision: 0.47; pnl: 1.14, spr: 0.47</p>
<h2 id="Linear-Discriminant-Analysis"><a href="#Linear-Discriminant-Analysis" class="headerlink" title="Linear Discriminant Analysis"></a>Linear Discriminant Analysis</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Model      = LinearDiscriminantAnalysis</span><br><span class="line">model_name = <span class="string">'Linear Discriminant Analysis'</span></span><br><span class="line">param      = &#123;<span class="string">'solver'</span>: <span class="string">'svd'</span>, <span class="string">'n_components'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line">param_init = &#123;&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'solver'</span>: [<span class="string">'svd'</span>, <span class="string">'lsqr'</span>], <span class="string">'n_components'</span>: [<span class="keyword">None</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.5, best param: {‘n_components’: None, ‘solver’: ‘svd’}<br>test precision: 0.47; pnl: 0.85, spr: -0.17</p>
<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Model      = KNeighborsClassifier</span><br><span class="line">model_name = <span class="string">'KNN'</span></span><br><span class="line">param      = &#123;<span class="string">'p'</span>: <span class="number">2</span>, <span class="string">'leaf_size'</span>: <span class="number">2</span>, <span class="string">'n_neighbors'</span>: <span class="number">100</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'p'</span>: <span class="number">2</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'n_neighbors'</span>: [<span class="number">5</span>, <span class="number">25</span>, <span class="number">100</span>], <span class="string">'leaf_size'</span>: [<span class="number">2</span>, <span class="number">25</span>, <span class="number">100</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.53, best param: {‘leaf_size’: 2, ‘n_neighbors’: 100}<br>test precision: 0.5; pnl: 1.95, spr: 1.85</p>
<h2 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model      = DecisionTreeClassifier</span><br><span class="line">model_name = <span class="string">'Decision Tree'</span></span><br><span class="line">param      = &#123;<span class="string">'random_state'</span>:<span class="number">0</span>, <span class="string">'criterion'</span>: <span class="string">'gini'</span>, <span class="string">'max_depth'</span>: <span class="keyword">None</span>, <span class="string">'max_features'</span>: <span class="number">10</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'random_state'</span>:<span class="number">0</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'criterion'</span>: [<span class="string">'gini'</span>, <span class="string">'entropy'</span>],</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="keyword">None</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'max_features'</span>: [<span class="keyword">None</span>, <span class="string">'auto'</span>, <span class="number">5</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.53, best param: {‘criterion’: ‘gini’, ‘max_depth’: 10, ‘max_features’: 5}<br>test precision: 0.49; pnl: 1.61, spr: 1.84</p>
<h2 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Model      = RandomForestClassifier</span><br><span class="line">model_name = <span class="string">'Random Forest'</span></span><br><span class="line">param      = &#123;<span class="string">'class_weight'</span>:<span class="string">'balanced'</span>,</span><br><span class="line">              <span class="string">'random_state'</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="string">'criterion'</span>: <span class="string">'entropy'</span>,</span><br><span class="line">              <span class="string">'max_depth'</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="string">'max_features'</span>: <span class="number">5</span>,</span><br><span class="line">              <span class="string">'n_estimators'</span>: <span class="number">200</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'class_weight'</span>:<span class="string">'balanced'</span>, <span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'criterion'</span>: [<span class="string">'gini'</span>, <span class="string">'entropy'</span>],</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'max_features'</span>: [<span class="number">5</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.53, best param: {‘criterion’: ‘gini’, ‘max_depth’: 5, ‘max_features’: 10}<br>test precision: 0.53; pnl: 1.55, spr: 1.16</p>
<h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Model      = AdaBoostClassifier</span><br><span class="line">model_name = <span class="string">'AdaBoost'</span></span><br><span class="line">param      = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'algorithm'</span>: <span class="string">'SAMME.R'</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>, <span class="string">'learning_rate'</span>: <span class="number">0.1</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'algorithm'</span>: <span class="string">'SAMME.R'</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'learning_rate'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.52, best param: {‘learning_rate’: 0.01}<br>test precision: 0.5; pnl: 0.86, spr: -0.09</p>
<h2 id="Gradient-Boost"><a href="#Gradient-Boost" class="headerlink" title="Gradient Boost"></a>Gradient Boost</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Model      = GradientBoostingClassifier</span><br><span class="line">model_name = <span class="string">'Gradient Boost'</span></span><br><span class="line">param      = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'warm_start'</span>: <span class="keyword">True</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>,</span><br><span class="line">              <span class="string">'max_depth'</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="string">'max_features'</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="string">'learning_rate'</span>: <span class="number">0.1</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'warm_start'</span>: <span class="keyword">True</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>,&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'max_features'</span>: [<span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.54, best param: {‘learning_rate’: 10, ‘max_depth’: 5, ‘max_features’: 5}<br>test precision: 0.48; pnl: 1.06, spr: 0.33</p>
<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_start_method(<span class="string">'forkserver'</span>, force=<span class="keyword">True</span>) <span class="comment"># enabling multi-threading</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Model      = XGBClassifier</span><br><span class="line">model_name = <span class="string">'XGBoost'</span></span><br><span class="line">param      = &#123;<span class="string">'n_jobs'</span>:<span class="number">4</span>, <span class="string">'seed'</span>:<span class="number">0</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>,</span><br><span class="line">              <span class="string">'max_depth'</span>: <span class="number">5</span>,</span><br><span class="line">              <span class="string">'min_child_weight'</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="string">'gamma'</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="string">'learning_rate'</span>: <span class="number">0.01</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'n_jobs'</span>:<span class="number">4</span>, <span class="string">'seed'</span>:<span class="number">0</span>, <span class="string">'n_estimators'</span>: <span class="number">200</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'min_child_weight'</span>: [<span class="number">1</span>, <span class="number">5</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.52, best param: {‘gamma’: 10, ‘learning_rate’: 0.01, ‘max_depth’: 25, ‘min_child_weight’: 1}<br>test precision: 0.52; pnl: 1.33, spr: 0.86</p>
<h2 id="SVC"><a href="#SVC" class="headerlink" title="SVC"></a>SVC</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Model      = SVC</span><br><span class="line">model_name = <span class="string">'SVC'</span></span><br><span class="line">param      = &#123;<span class="string">'probability'</span>:<span class="keyword">True</span>, <span class="string">'class_weight'</span>:<span class="string">'balanced'</span>, <span class="string">'C'</span>: <span class="number">10</span>, <span class="string">'gamma'</span>: <span class="number">0.01</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'probability'</span>:<span class="keyword">True</span>, <span class="string">'class_weight'</span>:<span class="string">'balanced'</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.64, best param: {‘C’: 0.1, ‘gamma’: 1}<br>test precision: 0.47; pnl: 1.31, spr: 0.73</p>
<h2 id="MLP-Classificer"><a href="#MLP-Classificer" class="headerlink" title="MLP Classificer"></a>MLP Classificer</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Model      = MLPClassifier</span><br><span class="line">model_name = <span class="string">'MLP Classifier'</span></span><br><span class="line">param      = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'hidden_layer_sizes'</span>: (<span class="number">25</span>, <span class="number">25</span>), <span class="string">'alpha'</span>: <span class="number">0.01</span>&#125;</span><br><span class="line">param_init = &#123;<span class="string">'random_state'</span>: <span class="number">0</span>&#125;</span><br><span class="line">param_grid = &#123;<span class="comment"># 'hidden_layer_sizes': [x for x in itertools.product((5, 25, 100),repeat=2)],</span></span><br><span class="line">              <span class="string">'alpha'</span>             : [<span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="comment"># 'activation'        : ['identity', 'logistic', 'tanh', 'relu'],</span></span><br><span class="line">              <span class="comment"># 'solver'            : ['lbfgs', 'sgd', 'adam'],</span></span><br><span class="line">              <span class="comment"># 'learning_rate'     : ['constant', 'invscaling', 'adaptive'],</span></span><br><span class="line">              <span class="comment"># 'max_itr'           : [100, 200, 1000]</span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b, c, d = run_model(Model, model_name, param, param_init, param_grid, search=<span class="keyword">True</span>)</span><br><span class="line">result     = result.join(a.cumprod() * <span class="number">1000</span>).rename(&#123;<span class="string">'pnl'</span>: model_name&#125;, axis=<span class="number">1</span>).dropna()</span><br><span class="line">comp       = comp.append(&#123;<span class="string">'Strategy'</span>: model_name, <span class="string">'Precision'</span>: b, <span class="string">'P&amp;L'</span>: c, <span class="string">'Sharpe Ratio'</span>: d&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>cv precision: 0.53, best param: {‘alpha’: 1}<br>test precision: 0.55; pnl: 2.06, spr: 1.79</p>
<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>The results are summarized as follow.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(comp.replace(<span class="string">'NA'</span>, <span class="number">0</span>).sort_values(<span class="string">'P&amp;L'</span>, ascending=<span class="keyword">False</span>), <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>Strategy</th>
      <th>Precision</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>10</th>
      <td>MLP Classifier</td>
      <td>0.55</td>
      <td>2.06</td>
      <td>1.79</td>
    </tr>
    <tr>
      <th>3</th>
      <td>KNN</td>
      <td>0.50</td>
      <td>1.95</td>
      <td>1.85</td>
    </tr>
    <tr>
      <th>0</th>
      <td>Baseline</td>
      <td>0.00</td>
      <td>1.69</td>
      <td>1.14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Decision Tree</td>
      <td>0.49</td>
      <td>1.61</td>
      <td>1.84</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Random Forest</td>
      <td>0.53</td>
      <td>1.55</td>
      <td>1.16</td>
    </tr>
    <tr>
      <th>8</th>
      <td>XGBoost</td>
      <td>0.52</td>
      <td>1.33</td>
      <td>0.86</td>
    </tr>
    <tr>
      <th>9</th>
      <td>SVC</td>
      <td>0.47</td>
      <td>1.31</td>
      <td>0.73</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Logistic Regression</td>
      <td>0.47</td>
      <td>1.14</td>
      <td>0.47</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Gradient Boost</td>
      <td>0.48</td>
      <td>1.06</td>
      <td>0.33</td>
    </tr>
    <tr>
      <th>6</th>
      <td>AdaBoost</td>
      <td>0.50</td>
      <td>0.86</td>
      <td>-0.09</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Linear Discriminant Analysis</td>
      <td>0.47</td>
      <td>0.85</td>
      <td>-0.17</td>
    </tr>
  </tbody>
</table>


<p>Plotting the cumulative return for each strategy with transaction fee reflected.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(result)</span><br><span class="line">plt.legend(result.columns, frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">30</span>)</span><br><span class="line">plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">30</span>))</span><br><span class="line">plt.ylabel(<span class="string">'Cumulative Value Based on $1000 Investment'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_58_0.png" alt="png"></p>
<p><br></p>
<h1 id="128214-Momentum-8634"><a href="#128214-Momentum-8634" class="headerlink" title="&#128214; Momentum &#8634;"></a><span id="02">&#128214; Momentum</span> <sup><a href="#nav">&#8634;</a></sup></h1><p>In this research I studied on the performance of simple and exponential moving average crossover strategies, with window sizes chosen by optimizing in-sample PNL, sharpe ratio and 30-day maximum drawdown. The calibrated strategy performs well, earning 500% cumulative return compared to baseline and a sharpe ratio of 1.30. The the 30-day maximum drawdown is similar to the baseline.</p>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Baseline</td>
      <td>0.28</td>
      <td>-1.48</td>
      <td>0.35</td>
    </tr>
    <tr>
      <th>1</th>
      <td>MA</td>
      <td>1.54</td>
      <td>1.30</td>
      <td>0.37</td>
    </tr>
    <tr>
      <th>2</th>
      <td>EWMA</td>
      <td>1.45</td>
      <td>1.10</td>
      <td>0.38</td>
    </tr>
  </tbody>
</table>

<!--more-->
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>It is no secret that price manipulations have always plagued the rising crypto-market. In this [paper], the auther studies large transactions behind the <code>tether</code> coin, and showed more evidence supporting that each large move in the crypto-market usually only come from the act of only a few. In this type of regime, I argue that technical indicator may be a better bet to profit compared to any attempt to apply fundamental analysis, because an increase in price no longer comes from the increase in a crypto’s intrinsic value, but rather speculation and manipulation. In this exercise I will mainly focus on moving average crossover techniques and its optimization.</p>
<h1 id="Packages-1"><a href="#Packages-1" class="headerlink" title="Packages"></a>Packages</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, HTML, Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span> register_matplotlib_converters</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">register_matplotlib_converters()</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = <span class="string">"serif"</span></span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>] = <span class="string">"DejaVu Serif"</span></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">12</span>, <span class="number">6</span>)</span><br><span class="line">plt.rcParams[<span class="string">'figure.dpi'</span>] = <span class="number">150</span></span><br><span class="line">plt.rcParams[<span class="string">'lines.linewidth'</span>] = <span class="number">0.75</span></span><br><span class="line">pd.set_option(<span class="string">'max_row'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Function-1"><a href="#Function-1" class="headerlink" title="Function"></a>Function</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> display(HTML(df.to_html(max_rows=<span class="number">10</span>, header=<span class="keyword">True</span>).replace(<span class="string">'&lt;table border="1" class="dataframe"&gt;'</span>,<span class="string">'&lt;table&gt;'</span>)))</span><br></pre></td></tr></table></figure>
<h1 id="Data-Exploration-1"><a href="#Data-Exploration-1" class="headerlink" title="Data Exploration"></a>Data Exploration</h1><p>I got the preliminary bitcoin data from <a href="https://api.bitcoincharts.com/v1/csv/" target="_blank" rel="noopener">bitcoincharts</a>. Data include price and volume information recorded by Bitstamp and split by seconds. This provide great granularity that can be grouped into any desirable levels later on.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'bitstampUSD.csv'</span>, header=<span class="keyword">None</span>, names=[<span class="string">'time'</span>, <span class="string">'price'</span>, <span class="string">'volume'</span>])</span><br><span class="line">data[<span class="string">'time'</span>] = pd.to_datetime(data[<span class="string">'time'</span>], unit=<span class="string">'s'</span>)</span><br><span class="line">data.set_index(<span class="string">'time'</span>, inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>Get 3-month treasury data.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'https://fred.stlouisfed.org/graph/fredgraph.csv?id=DTB3'</span></span><br><span class="line">tr  = pd.read_csv(url, index_col=<span class="number">0</span>, parse_dates=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>Data are grouped in to daily, with average applied to price and sum applied to trade volume. The backtest period is selected to be from 2018 to 2019, where the market was in continuous downturn. This ensure that our strategy performs well in adverse scenarios.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df1 = data.loc[<span class="string">'2018-01-01'</span>:<span class="string">'2019-01-01'</span>].resample(<span class="string">'1D'</span>).agg(&#123;<span class="string">'price'</span>: np.mean, <span class="string">'volume'</span>: np.sum&#125;)</span><br><span class="line">df2 = tr.loc[<span class="string">'2018-01-01'</span>:<span class="string">'2019-01-01'</span>]</span><br><span class="line">df = df1.join(df2).replace(<span class="string">'.'</span>, np.NaN).fillna(method=<span class="string">'ffill'</span>).fillna(method=<span class="string">'bfill'</span>).rename(&#123;<span class="string">'DTB3'</span>: <span class="string">'tr'</span>&#125;, axis=<span class="number">1</span>)</span><br><span class="line">df.tr = df.tr.astype(float)/<span class="number">100</span></span><br><span class="line">disp(df)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>volume</th>
      <th>tr</th>
    </tr>
    <tr>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2018-01-01</th>
      <td>13386.429268</td>
      <td>7688.030685</td>
      <td>0.0142</td>
    </tr>
    <tr>
      <th>2018-01-02</th>
      <td>14042.643870</td>
      <td>16299.669303</td>
      <td>0.0142</td>
    </tr>
    <tr>
      <th>2018-01-03</th>
      <td>14947.898046</td>
      <td>12275.001197</td>
      <td>0.0139</td>
    </tr>
    <tr>
      <th>2018-01-04</th>
      <td>14802.363927</td>
      <td>15004.018593</td>
      <td>0.0139</td>
    </tr>
    <tr>
      <th>2018-01-05</th>
      <td>15967.972719</td>
      <td>16248.914680</td>
      <td>0.0137</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2018-12-28</th>
      <td>3752.739978</td>
      <td>13055.718407</td>
      <td>0.0235</td>
    </tr>
    <tr>
      <th>2018-12-29</th>
      <td>3862.153295</td>
      <td>6901.382332</td>
      <td>0.0235</td>
    </tr>
    <tr>
      <th>2018-12-30</th>
      <td>3783.210991</td>
      <td>5736.453708</td>
      <td>0.0235</td>
    </tr>
    <tr>
      <th>2018-12-31</th>
      <td>3745.258717</td>
      <td>6667.163737</td>
      <td>0.0240</td>
    </tr>
    <tr>
      <th>2019-01-01</th>
      <td>3709.889253</td>
      <td>5149.606277</td>
      <td>0.0240</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(df.price, c=<span class="string">'tab:grey'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Bitcoin Price in USD'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_15_0.png" alt="png"></p>
<h1 id="Simple-Moving-Average"><a href="#Simple-Moving-Average" class="headerlink" title="Simple Moving Average"></a>Simple Moving Average</h1><p>A simple moving average strategy use the cross-over point of two moving averages as the trading signal. Here we use grid-search to find out the window size pair that optimizes our desired metrics, namely P&amp;L, Sharpe ratio and 30-day maximum drawdown.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moving_average</span><span class="params">(df0, ma1, ma2, transactionFee=<span class="number">0</span>, runBaseline=False, returnStats=True, ewma=False)</span>:</span></span><br><span class="line">    df = df0.copy()</span><br><span class="line">    <span class="keyword">if</span> ewma:</span><br><span class="line">        df[<span class="string">'ma'</span>+str(ma1)] = df.price.ewm(span=ma1).mean()</span><br><span class="line">        df[<span class="string">'ma'</span>+str(ma2)] = df.price.ewm(span=ma2).mean()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        df[<span class="string">'ma'</span>+str(ma1)] = df.price.rolling(ma1).mean()</span><br><span class="line">        df[<span class="string">'ma'</span>+str(ma2)] = df.price.rolling(ma2).mean()</span><br><span class="line"></span><br><span class="line">    df[<span class="string">'ind'</span>] = df[<span class="string">'ma'</span>+str(ma1)] &gt; df[<span class="string">'ma'</span>+str(ma2)]</span><br><span class="line">    df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    df[<span class="string">'buy'</span>] = (df.ind != df.ind.shift(<span class="number">1</span>)) &amp; df.ind &amp; (df.index != df.index[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'sell'</span>] = (df.ind != df.ind.shift(<span class="number">1</span>)) &amp; df.ind.shift(<span class="number">1</span>) &amp; (df.buy.cumsum() &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> runBaseline:</span><br><span class="line">        df.ind = <span class="number">1</span></span><br><span class="line">        df.buy = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    df[<span class="string">'pnl'</span>] = df.ind * (df.buy.cumsum() &gt; <span class="number">0</span>) * df.price.shift(<span class="number">-1</span>) / df.price</span><br><span class="line">    df.pnl = df.pnl * np.where(df.ind != df.ind.shift(<span class="number">1</span>), <span class="number">1</span>-transactionFee, <span class="number">1</span>)</span><br><span class="line">    df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    df.pnl.replace(<span class="number">0</span>, <span class="number">1</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> returnStats:</span><br><span class="line">        df[<span class="string">'tr_daily'</span>] = (<span class="number">1</span> + df.tr)**(<span class="number">1</span>/<span class="number">365</span>) - <span class="number">1</span></span><br><span class="line">        pnl            = round(df.pnl.cumprod()[<span class="number">-1</span>], <span class="number">2</span>)</span><br><span class="line">        sharpe_ratio   = round(np.mean(df.pnl<span class="number">-1</span>-df.tr_daily) / np.std(df.pnl<span class="number">-1</span>) * np.sqrt(<span class="number">365</span>), <span class="number">2</span>)</span><br><span class="line">        mdd_dur        = <span class="number">30</span></span><br><span class="line">        max_draw_down  = round(np.max(df.pnl.cumprod().rolling(mdd_dur).max() -</span><br><span class="line">                                     df.pnl.cumprod().shift(mdd_dur)), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> pnl, sharpe_ratio, max_draw_down</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure>
<p>First let’s compute the baseline results, from a simple buy and hold strategy.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pnl, spr, mdd = moving_average(df, <span class="number">1</span>, <span class="number">1</span>, runBaseline=<span class="keyword">True</span>)</span><br><span class="line">comp = pd.DataFrame(&#123;<span class="string">'Strategy'</span>: <span class="string">'Baseline'</span>, <span class="string">'P&amp;L'</span>: pnl, <span class="string">'Sharpe Ratio'</span>: spr, <span class="string">'Maximum Drawdown'</span>: mdd&#125;, index=[<span class="number">0</span>])</span><br><span class="line">disp(comp)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Baseline</td>
      <td>0.28</td>
      <td>-1.48</td>
      <td>0.35</td>
    </tr>
  </tbody>
</table>


<p>Performing grid-search for the optimal window size pair. Note that 25bps of transaction fee is added, this is to reflect the typical fee charged by crypto exchanges. I used coinbase pro’s fee here as an example.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fee = <span class="number">0.0025</span></span><br><span class="line">test_range = np.arange(<span class="number">1</span>, <span class="number">61</span>)</span><br><span class="line">result_ma = pd.DataFrame(columns=[<span class="string">'Strategy'</span>,<span class="string">'MA1'</span>, <span class="string">'MA2'</span>, <span class="string">'P&amp;L'</span>, <span class="string">'Sharpe Ratio'</span>, <span class="string">'Maximum Drawdown'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># grid-search</span></span><br><span class="line"><span class="keyword">for</span> ma1 <span class="keyword">in</span> test_range:</span><br><span class="line">    <span class="keyword">for</span> ma2 <span class="keyword">in</span> test_range:</span><br><span class="line">        <span class="keyword">if</span> ma2 &gt; ma1 + <span class="number">3</span>:</span><br><span class="line">            pnl, spr, mdd = moving_average(df, ma1, ma2, transactionFee=fee)</span><br><span class="line">            result_ma = result_ma.append(&#123;<span class="string">'Strategy'</span>: <span class="string">'MA'</span>, <span class="string">'MA1'</span>: ma1, <span class="string">'MA2'</span>: ma2,</span><br><span class="line">                                          <span class="string">'P&amp;L'</span>: pnl,</span><br><span class="line">                                          <span class="string">'Sharpe Ratio'</span>: spr,</span><br><span class="line">                                          <span class="string">'Maximum Drawdown'</span>: mdd&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(result_ma.sort_values(<span class="string">'P&amp;L'</span>, ascending=<span class="keyword">False</span>).head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>MA1</th>
      <th>MA2</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>MA</td>
      <td>1</td>
      <td>7</td>
      <td>1.54</td>
      <td>1.30</td>
      <td>0.37</td>
    </tr>
    <tr>
      <th>3</th>
      <td>MA</td>
      <td>1</td>
      <td>8</td>
      <td>1.31</td>
      <td>0.86</td>
      <td>0.34</td>
    </tr>
    <tr>
      <th>12</th>
      <td>MA</td>
      <td>1</td>
      <td>17</td>
      <td>1.26</td>
      <td>0.81</td>
      <td>0.33</td>
    </tr>
    <tr>
      <th>11</th>
      <td>MA</td>
      <td>1</td>
      <td>16</td>
      <td>1.26</td>
      <td>0.81</td>
      <td>0.32</td>
    </tr>
    <tr>
      <th>9</th>
      <td>MA</td>
      <td>1</td>
      <td>14</td>
      <td>1.25</td>
      <td>0.78</td>
      <td>0.32</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(result_ma.sort_values(<span class="string">'Sharpe Ratio'</span>, ascending=<span class="keyword">False</span>).head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>MA1</th>
      <th>MA2</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>MA</td>
      <td>1</td>
      <td>7</td>
      <td>1.54</td>
      <td>1.30</td>
      <td>0.37</td>
    </tr>
    <tr>
      <th>3</th>
      <td>MA</td>
      <td>1</td>
      <td>8</td>
      <td>1.31</td>
      <td>0.86</td>
      <td>0.34</td>
    </tr>
    <tr>
      <th>11</th>
      <td>MA</td>
      <td>1</td>
      <td>16</td>
      <td>1.26</td>
      <td>0.81</td>
      <td>0.32</td>
    </tr>
    <tr>
      <th>12</th>
      <td>MA</td>
      <td>1</td>
      <td>17</td>
      <td>1.26</td>
      <td>0.81</td>
      <td>0.33</td>
    </tr>
    <tr>
      <th>9</th>
      <td>MA</td>
      <td>1</td>
      <td>14</td>
      <td>1.25</td>
      <td>0.78</td>
      <td>0.32</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(result_ma.sort_values(<span class="string">'Maximum Drawdown'</span>, ascending=<span class="keyword">True</span>).head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>MA1</th>
      <th>MA2</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1129</th>
      <td>MA</td>
      <td>26</td>
      <td>59</td>
      <td>0.51</td>
      <td>-3.38</td>
      <td>0.04</td>
    </tr>
    <tr>
      <th>1099</th>
      <td>MA</td>
      <td>25</td>
      <td>60</td>
      <td>0.54</td>
      <td>-3.19</td>
      <td>0.04</td>
    </tr>
    <tr>
      <th>1130</th>
      <td>MA</td>
      <td>26</td>
      <td>60</td>
      <td>0.52</td>
      <td>-3.29</td>
      <td>0.04</td>
    </tr>
    <tr>
      <th>1160</th>
      <td>MA</td>
      <td>27</td>
      <td>60</td>
      <td>0.52</td>
      <td>-3.35</td>
      <td>0.04</td>
    </tr>
    <tr>
      <th>1128</th>
      <td>MA</td>
      <td>26</td>
      <td>58</td>
      <td>0.54</td>
      <td>-3.01</td>
      <td>0.06</td>
    </tr>
  </tbody>
</table>


<p>Choosing 1-7 as our selected window pair. Plotting the PNL over the 1-year backtest period.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bt = df.copy()</span><br><span class="line">bt[<span class="string">'Baseline: Buy and Hold'</span>] = bt.price/bt.price[<span class="number">0</span>]</span><br><span class="line">bt[<span class="string">'Strategy 1: MA 1-7'</span>]          = moving_average(df.copy(), <span class="number">1</span>, <span class="number">7</span>, returnStats=<span class="keyword">False</span>).pnl.cumprod()</span><br><span class="line">bt[<span class="string">'Strategy 2: MA 1-7 with Fee'</span>] = moving_average(df.copy(), <span class="number">1</span>, <span class="number">7</span>, transactionFee=fee, returnStats=<span class="keyword">False</span>).pnl.cumprod()</span><br><span class="line"></span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">3</span>], c=<span class="string">'tab:grey'</span>)</span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">4</span>], c=<span class="string">'tab:red'</span>)</span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">5</span>], c=<span class="string">'tab:red'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.legend(bt.columns[<span class="number">3</span>:<span class="number">6</span>], frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cumulative Asset Value Based on $1 Investment'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_27_0.png" alt="png"></p>
<p>It seems that the trading fee does not have a material impact on the result. We plot the buy/sell signals as follow.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bt = df.copy()</span><br><span class="line">ma = moving_average(bt, <span class="number">1</span>, <span class="number">7</span>, transactionFee=fee, returnStats=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(bt.price, c=<span class="string">'black'</span>, label=<span class="string">'Bitcoin Price'</span>)</span><br><span class="line">plt.plot(ma.price.loc[ma.buy], <span class="string">'^'</span>, markersize=<span class="number">3</span>, color=<span class="string">'g'</span>, label=<span class="string">'Buy Signal'</span>)</span><br><span class="line">plt.plot(ma.price.loc[ma.sell], <span class="string">'v'</span>, markersize=<span class="number">3</span>, color=<span class="string">'r'</span>, label=<span class="string">'Sell Signal'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_29_0.png" alt="png"></p>
<h1 id="EWMA"><a href="#EWMA" class="headerlink" title="EWMA"></a>EWMA</h1><p>Perform the same grid-search optimization using EWMA (Exponentially Weighted Moving Averages).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_range = np.arange(<span class="number">1</span>, <span class="number">61</span>)</span><br><span class="line">result_ewma = pd.DataFrame(columns=[<span class="string">'Strategy'</span>,<span class="string">'MA1'</span>, <span class="string">'MA2'</span>, <span class="string">'P&amp;L'</span>, <span class="string">'Sharpe Ratio'</span>, <span class="string">'Maximum Drawdown'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># grid-search</span></span><br><span class="line"><span class="keyword">for</span> ma1 <span class="keyword">in</span> test_range:</span><br><span class="line">    <span class="keyword">for</span> ma2 <span class="keyword">in</span> test_range:</span><br><span class="line">        <span class="keyword">if</span> ma2 &gt; ma1 + <span class="number">3</span>:</span><br><span class="line">            pnl, spr, mdd = moving_average(df, ma1, ma2, transactionFee=fee, ewma=<span class="keyword">True</span>)</span><br><span class="line">            result_ewma = result_ewma.append(&#123;<span class="string">'Strategy'</span>: <span class="string">'EWMA'</span>, <span class="string">'MA1'</span>: ma1, <span class="string">'MA2'</span>: ma2,</span><br><span class="line">                                    <span class="string">'P&amp;L'</span>: pnl,</span><br><span class="line">                                    <span class="string">'Sharpe Ratio'</span>: spr,</span><br><span class="line">                                    <span class="string">'Maximum Drawdown'</span>: mdd&#125;, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(result_ewma.sort_values(<span class="string">'P&amp;L'</span>, ascending=<span class="keyword">False</span>).head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>MA1</th>
      <th>MA2</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>EWMA</td>
      <td>1</td>
      <td>5</td>
      <td>1.45</td>
      <td>1.10</td>
      <td>0.38</td>
    </tr>
    <tr>
      <th>1</th>
      <td>EWMA</td>
      <td>1</td>
      <td>6</td>
      <td>1.39</td>
      <td>0.98</td>
      <td>0.39</td>
    </tr>
    <tr>
      <th>5</th>
      <td>EWMA</td>
      <td>1</td>
      <td>10</td>
      <td>1.38</td>
      <td>1.01</td>
      <td>0.32</td>
    </tr>
    <tr>
      <th>10</th>
      <td>EWMA</td>
      <td>1</td>
      <td>15</td>
      <td>1.36</td>
      <td>0.99</td>
      <td>0.38</td>
    </tr>
    <tr>
      <th>6</th>
      <td>EWMA</td>
      <td>1</td>
      <td>11</td>
      <td>1.31</td>
      <td>0.87</td>
      <td>0.31</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(result_ewma.sort_values(<span class="string">'Sharpe Ratio'</span>, ascending=<span class="keyword">False</span>).head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>MA1</th>
      <th>MA2</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>EWMA</td>
      <td>1</td>
      <td>5</td>
      <td>1.45</td>
      <td>1.10</td>
      <td>0.38</td>
    </tr>
    <tr>
      <th>5</th>
      <td>EWMA</td>
      <td>1</td>
      <td>10</td>
      <td>1.38</td>
      <td>1.01</td>
      <td>0.32</td>
    </tr>
    <tr>
      <th>10</th>
      <td>EWMA</td>
      <td>1</td>
      <td>15</td>
      <td>1.36</td>
      <td>0.99</td>
      <td>0.38</td>
    </tr>
    <tr>
      <th>1</th>
      <td>EWMA</td>
      <td>1</td>
      <td>6</td>
      <td>1.39</td>
      <td>0.98</td>
      <td>0.39</td>
    </tr>
    <tr>
      <th>12</th>
      <td>EWMA</td>
      <td>1</td>
      <td>17</td>
      <td>1.31</td>
      <td>0.89</td>
      <td>0.38</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp(result_ewma.sort_values(<span class="string">'Maximum Drawdown'</span>, ascending=<span class="keyword">True</span>).head())</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>MA1</th>
      <th>MA2</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>797</th>
      <td>EWMA</td>
      <td>17</td>
      <td>42</td>
      <td>0.51</td>
      <td>-2.34</td>
      <td>0.18</td>
    </tr>
    <tr>
      <th>1069</th>
      <td>EWMA</td>
      <td>25</td>
      <td>30</td>
      <td>0.53</td>
      <td>-2.22</td>
      <td>0.18</td>
    </tr>
    <tr>
      <th>1068</th>
      <td>EWMA</td>
      <td>25</td>
      <td>29</td>
      <td>0.51</td>
      <td>-2.29</td>
      <td>0.18</td>
    </tr>
    <tr>
      <th>1067</th>
      <td>EWMA</td>
      <td>24</td>
      <td>60</td>
      <td>0.67</td>
      <td>-1.92</td>
      <td>0.18</td>
    </tr>
    <tr>
      <th>1066</th>
      <td>EWMA</td>
      <td>24</td>
      <td>59</td>
      <td>0.67</td>
      <td>-1.92</td>
      <td>0.18</td>
    </tr>
  </tbody>
</table>


<p>Selecting 1-7 as our window pair. Plotting the cumulative strategy return and buy/sell signals.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bt = df.copy()</span><br><span class="line">bt[<span class="string">'Baseline: Buy and Hold'</span>] = bt.price/bt.price[<span class="number">0</span>]</span><br><span class="line">bt[<span class="string">'Strategy 1: EMWA 1-5 (Best PNL)'</span>]          = moving_average(df.copy(), <span class="number">1</span>, <span class="number">5</span>, returnStats=<span class="keyword">False</span>, ewma=<span class="keyword">True</span>).pnl.cumprod()</span><br><span class="line">bt[<span class="string">'Strategy 2: EMWA 1-5 (Best PNL) with Fee'</span>] = moving_average(df.copy(), <span class="number">1</span>, <span class="number">5</span>, transactionFee=fee, returnStats=<span class="keyword">False</span>, ewma=<span class="keyword">True</span>).pnl.cumprod()</span><br><span class="line"></span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">3</span>], c=<span class="string">'tab:grey'</span>)</span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">4</span>], c=<span class="string">'tab:blue'</span>)</span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">5</span>], c=<span class="string">'tab:blue'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.legend(bt.columns[<span class="number">3</span>:<span class="number">6</span>], frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cumulative Asset Value Based on $1 Investment'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_37_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bt = df.copy()</span><br><span class="line">ma = moving_average(bt, <span class="number">1</span>, <span class="number">5</span>, transactionFee=fee, returnStats=<span class="keyword">False</span>, ewma=<span class="keyword">True</span>).copy()</span><br><span class="line"></span><br><span class="line">plt.plot(bt.price, c=<span class="string">'black'</span>, label=<span class="string">'Bitcoin Price'</span>)</span><br><span class="line">plt.plot(ma.price.loc[ma.buy], <span class="string">'^'</span>, markersize=<span class="number">3</span>, color=<span class="string">'g'</span>, label=<span class="string">'Buy Signal'</span>)</span><br><span class="line">plt.plot(ma.price.loc[ma.sell], <span class="string">'v'</span>, markersize=<span class="number">3</span>, color=<span class="string">'r'</span>, label=<span class="string">'Sell Signal'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_38_0.png" alt="png"></p>
<p>Comparing the MA and EWMA strategies.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bt = df.copy()</span><br><span class="line">bt[<span class="string">'Baseline: Buy and Hold'</span>] = bt.price/bt.price[<span class="number">0</span>]</span><br><span class="line">bt[<span class="string">'Strategy 1: Moving Average 1-7'</span>] = moving_average(df.copy(), <span class="number">1</span>, <span class="number">7</span>, transactionFee=fee, returnStats=<span class="keyword">False</span>).pnl.cumprod()</span><br><span class="line">bt[<span class="string">'Strategy 2: EWMA 1-5'</span>]           = moving_average(df.copy(), <span class="number">1</span>, <span class="number">5</span>, transactionFee=fee, returnStats=<span class="keyword">False</span>, ewma=<span class="keyword">True</span>).pnl.cumprod()</span><br><span class="line"></span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">3</span>], c=<span class="string">'tab:grey'</span>)</span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">4</span>], c=<span class="string">'tab:red'</span>)</span><br><span class="line">plt.plot(bt.iloc[:, <span class="number">5</span>], c=<span class="string">'tab:blue'</span>)</span><br><span class="line">plt.legend(bt.columns[<span class="number">3</span>:<span class="number">6</span>], frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cumulative Asset Value Based on $1 Investment'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_40_0.png" alt="png"></p>
<p>As we can see, the MA strategy slightly outperforms the EWMA strategy in all three metrics.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comp = comp.append(result_ma.iloc[<span class="number">2</span>, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]], ignore_index=<span class="keyword">True</span>)</span><br><span class="line">comp = comp.append(result_ewma.iloc[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]], ignore_index=<span class="keyword">True</span>)</span><br><span class="line">disp(comp)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Baseline</td>
      <td>0.28</td>
      <td>-1.48</td>
      <td>0.35</td>
    </tr>
    <tr>
      <th>1</th>
      <td>MA</td>
      <td>1.54</td>
      <td>1.30</td>
      <td>0.37</td>
    </tr>
    <tr>
      <th>2</th>
      <td>EWMA</td>
      <td>1.45</td>
      <td>1.10</td>
      <td>0.38</td>
    </tr>
  </tbody>
</table>


<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>Starting 08-01-2019, I have implemented the optimal MA strategy on a VPS (virtual private server), running 24/7 through the coinbase pro api. Will post update on this periodically.</p>
<p><br></p>
<h1 id="128214-Perpetual-Swap-Funding-8634"><a href="#128214-Perpetual-Swap-Funding-8634" class="headerlink" title="&#128214; Perpetual Swap Funding &#8634;"></a><span id="03">&#128214; Perpetual Swap Funding</span> <sup><a href="#nav">&#8634;</a></sup></h1><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>In this research, we dive into the bitcoin <a href="https://www.bitmex.com/app/perpetualContractsGuide" target="_blank" rel="noopener">perpetual swap</a> contract on the BitMEX exchange. Specifically, we are interested at the predicting power of its funding structure and the subsequent applications to algorithmic trading.</p>
<p>Traditionally, <code>future</code> provides additional liquidity and leverage to market participants. With <script type="math/tex">10k</script> USD, one may either buy <script type="math/tex">1</script> Bitcoin, or <script type="math/tex">100</script> Bitcoin futures which provide <script type="math/tex">100</script>x more gain potentials. However, every future contract has an expiry date and can be traded at significantly spread. The first Bitcoin future in the U.S. was traded on Dec 10, 2017 on the Cboe Futures Exchange.</p>
<p>The Bitcoin <code>perpetual swap</code> contract, on the contrast, does not have an expiry date thus removing the need to rollover. It trades much closer to the underlying Bitcoin price via a funding mechanism. On BitMEX, the swap holders must exchange fundings every <script type="math/tex">8</script> hours between the long and short counter-parties. This create price pressure for the <code>swap price</code> to converge to the actual <code>Bitcoin price</code>.</p>
<p>For example, if swap price <script type="math/tex">></script> Bitcoin price, then the funding would be positive and therefore the long positions will need to pay funding to its short counter-parties. This creates pressures for the swap price to decrease and move towards the Bitcoin price.</p>
<h1 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h1><p>The funding creates a great monetary incentive if you are holding the contract on the right side and we would like to see if we can capture the funding gain overtime with an algorithmic trading strategy. Since the funding is announced <script type="math/tex">8</script> hours before the actual exchange happens, we have an <script type="math/tex">8</script> hour window of entry after knowing that a profitable funding will occur. After we enter the contract and collect the funding, we then have another <script type="math/tex">8</script> hour window for exiting (this assumes we only want to enter <script type="math/tex">1</script> contract at any given time). We will try to look for optimal enter/exit time combinations and evaluate performances.</p>
<p>This is similar to the mean reversion strategy discussed by BitMEX’s founder Arthur Hayes in his blog<sup><a href="#1">[1]</a></sup><sup><a href="#2">[2]</a></sup>. We are carrying this strategy further, analyzing enter and exit options at more granular level and proposing a more optimal execution strategy.</p>
<h1 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, HTML, Image</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span> register_matplotlib_converters</span><br><span class="line">register_matplotlib_converters()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = <span class="string">"serif"</span></span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>] = <span class="string">"DejaVu Serif"</span></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">12</span>, <span class="number">6</span>)</span><br><span class="line">plt.rcParams[<span class="string">'figure.dpi'</span>] = <span class="number">400</span></span><br><span class="line">plt.rcParams[<span class="string">'lines.linewidth'</span>] = <span class="number">0.75</span></span><br><span class="line">pd.set_option(<span class="string">'max_row'</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp</span><span class="params">(df, max_rows=<span class="number">6</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> display(HTML(df.to_html(max_rows=max_rows, header=<span class="keyword">True</span>).replace(<span class="string">'&lt;table border="1" class="dataframe"&gt;'</span>,<span class="string">'&lt;table&gt;'</span>)))</span><br></pre></td></tr></table></figure>
<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><p>We can retrieve historical funding rates and minutely swap price data from the BitMEX api.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_funding</span><span class="params">()</span>:</span></span><br><span class="line">    start_date = datetime.datetime(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=pytz.utc)</span><br><span class="line">    end_date   = datetime.datetime.now(tz=pytz.utc) - datetime.timedelta(days=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    endpoint = <span class="string">'https://www.bitmex.com/api/v1/funding'</span></span><br><span class="line">    payload  = &#123;<span class="string">'count'</span>:<span class="string">'500'</span>, <span class="string">'reverse'</span>:<span class="string">'false'</span>, <span class="string">'symbol'</span>:<span class="string">'XBTUSD'</span>, <span class="string">'startTime'</span>: start_date&#125;</span><br><span class="line">    response = requests.get(endpoint, params=payload)</span><br><span class="line"></span><br><span class="line">    funding_rates_df = pd.DataFrame(response.json())</span><br><span class="line">    funding_rates_df[<span class="string">'timestamp'</span>] = pd.to_datetime(funding_rates_df[<span class="string">'timestamp'</span>], utc=<span class="keyword">True</span>)</span><br><span class="line">    funding_rates_df.set_index(<span class="string">'timestamp'</span>, drop=<span class="keyword">True</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">    start_date = funding_rates_df.index[<span class="number">-1</span>] + datetime.timedelta(hours=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start_date &lt; end_date:</span><br><span class="line">        time.sleep(random()) <span class="comment"># requesting too frequently will cause error</span></span><br><span class="line">        endpoint = <span class="string">'https://www.bitmex.com/api/v1/funding'</span></span><br><span class="line">        payload  = &#123;<span class="string">'count'</span>:<span class="string">'500'</span>, <span class="string">'reverse'</span>:<span class="string">'false'</span>, <span class="string">'symbol'</span>:<span class="string">'XBTUSD'</span>, <span class="string">'startTime'</span>: start_date&#125;</span><br><span class="line">        response = requests.get(endpoint, params=payload)</span><br><span class="line"></span><br><span class="line">        funding_rates_df_tmp = pd.DataFrame(response.json())</span><br><span class="line">        funding_rates_df_tmp[<span class="string">'timestamp'</span>] = pd.to_datetime(funding_rates_df_tmp[<span class="string">'timestamp'</span>], utc=<span class="keyword">True</span>)</span><br><span class="line">        funding_rates_df_tmp.set_index(<span class="string">'timestamp'</span>, drop=<span class="keyword">True</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">        start_date = funding_rates_df_tmp.index[<span class="number">-1</span>] + datetime.timedelta(hours=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        funding_rates_df = funding_rates_df.append([funding_rates_df_tmp])</span><br><span class="line"></span><br><span class="line">    funding_rates_df.to_csv(<span class="string">'funding_rates_df.csv'</span>)</span><br><span class="line">    <span class="keyword">return</span> funding_rates_df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_swap</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># start_date = datetime.datetime(2016, 5, 14, 0, 0, 0, 0, tzinfo=pytz.utc)</span></span><br><span class="line">    <span class="comment"># end_date   = datetime.datetime.now(tz=pytz.utc)</span></span><br><span class="line"></span><br><span class="line">    start_date = datetime.datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=pytz.utc)</span><br><span class="line">    end_date   = datetime.datetime(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">0</span>, tzinfo=pytz.utc)</span><br><span class="line"></span><br><span class="line">    endpoint = <span class="string">'https://www.bitmex.com/api/v1/trade/bucketed'</span></span><br><span class="line">    payload  = &#123;<span class="string">'count'</span>:<span class="string">'1000'</span>, <span class="string">'reverse'</span>:<span class="string">'false'</span>,</span><br><span class="line">                <span class="string">'symbol'</span>:<span class="string">'XBTUSD'</span>, <span class="string">'startTime'</span>: start_date, <span class="string">'binSize'</span>: <span class="string">'1m'</span>&#125;</span><br><span class="line">    response = requests.get(endpoint, params=payload)</span><br><span class="line">    print(response)</span><br><span class="line">    swap_df = pd.DataFrame(response.json())</span><br><span class="line">    swap_df[<span class="string">'timestamp'</span>] = pd.to_datetime(swap_df[<span class="string">'timestamp'</span>], utc=<span class="keyword">True</span>)</span><br><span class="line">    swap_df.set_index(<span class="string">'timestamp'</span>, drop=<span class="keyword">True</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">    start_date = swap_df.index[<span class="number">-1</span>] + datetime.timedelta(hours=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start_date &lt; end_date:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            time.sleep(random())</span><br><span class="line">            endpoint = <span class="string">'https://www.bitmex.com/api/v1/trade/bucketed'</span></span><br><span class="line">            payload  = &#123;<span class="string">'count'</span>:<span class="string">'1000'</span>, <span class="string">'reverse'</span>:<span class="string">'false'</span>,</span><br><span class="line">                        <span class="string">'symbol'</span>:<span class="string">'XBTUSD'</span>, <span class="string">'startTime'</span>: start_date, <span class="string">'binSize'</span>: <span class="string">'1m'</span>&#125;</span><br><span class="line">            response = requests.get(endpoint, params=payload)</span><br><span class="line"></span><br><span class="line">            swap_df_tmp = pd.DataFrame(response.json())</span><br><span class="line">            swap_df_tmp[<span class="string">'timestamp'</span>] = pd.to_datetime(swap_df_tmp[<span class="string">'timestamp'</span>], utc=<span class="keyword">True</span>)</span><br><span class="line">            swap_df_tmp.set_index(<span class="string">'timestamp'</span>, drop=<span class="keyword">True</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">            start_date = swap_df_tmp.index[<span class="number">-1</span>] + datetime.timedelta(hours=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            swap_df = swap_df.append([swap_df_tmp])</span><br><span class="line">            print(start_date)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    swap_df.to_csv(<span class="string">"swap_df_1m_2019.csv"</span>)</span><br><span class="line">    <span class="keyword">return</span> swap_df_tmp</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">swap = pd.read_csv(<span class="string">"swap_df_1m.csv"</span>)</span><br><span class="line">swap[<span class="string">'timestamp'</span>] = pd.to_datetime(swap[<span class="string">'timestamp'</span>], utc=<span class="keyword">True</span>)</span><br><span class="line">swap.set_index(<span class="string">'timestamp'</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">swap.fillna(method=<span class="string">'ffill'</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">swap.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">funding = pd.read_csv(<span class="string">"funding_rates_df.csv"</span>)</span><br><span class="line">funding[<span class="string">'timestamp'</span>] = pd.to_datetime(funding[<span class="string">'timestamp'</span>], utc=<span class="keyword">True</span>)</span><br><span class="line">funding.set_index(<span class="string">'timestamp'</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">funding = funding[<span class="string">'fundingRate'</span>].to_frame()</span><br><span class="line">funding = funding.loc[funding.index &gt;= <span class="string">'2016-06-05'</span>]</span><br><span class="line"></span><br><span class="line">df = swap.join([funding])</span><br><span class="line"></span><br><span class="line"><span class="comment"># swap return by holding from funding time -30m to +1m</span></span><br><span class="line">df[<span class="string">'swapRet'</span>] = df.swapPrice.shift(<span class="number">-300</span>) / df.swapPrice.shift(<span class="number">30</span>) - <span class="number">1</span></span><br><span class="line">df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">disp(df)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>swapPrice</th>
      <th>fundingRate</th>
      <th>swapRet</th>
    </tr>
    <tr>
      <th>timestamp</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2016-06-05 04:00:00+00:00</th>
      <td>585.6001</td>
      <td>0.000242</td>
      <td>-0.002756</td>
    </tr>
    <tr>
      <th>2016-06-05 12:00:00+00:00</th>
      <td>581.3784</td>
      <td>0.000237</td>
      <td>-0.004034</td>
    </tr>
    <tr>
      <th>2016-06-05 20:00:00+00:00</th>
      <td>580.9900</td>
      <td>0.000234</td>
      <td>-0.000978</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2019-11-06 04:00:00+00:00</th>
      <td>9314.4560</td>
      <td>0.000100</td>
      <td>0.013475</td>
    </tr>
    <tr>
      <th>2019-11-06 12:00:00+00:00</th>
      <td>9395.8470</td>
      <td>0.000198</td>
      <td>-0.008921</td>
    </tr>
    <tr>
      <th>2019-11-06 20:00:00+00:00</th>
      <td>9301.4603</td>
      <td>0.000374</td>
      <td>0.002900</td>
    </tr>
  </tbody>
</table>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">colors = np.where(df.fundingRate &gt;= <span class="number">0</span>, <span class="string">'tab:green'</span>, <span class="string">'tab:red'</span>)</span><br><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax1.plot(df.swapPrice, c=<span class="string">'black'</span>, linewidth=<span class="number">0.3</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'swapPrice'</span>)</span><br><span class="line">ax1.set_ylim(<span class="number">-22500</span>, <span class="number">22500</span>)</span><br><span class="line"></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax2.scatter(df.index, df.fundingRate, c=colors, s=<span class="number">0.1</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">'fundingRate'</span>)</span><br><span class="line">ax2.set_ylim(<span class="number">-0.0075</span>, <span class="number">0.025</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Swap Price vs Funding Rate"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_11_0.png" alt="output_11_0.png"></p>
<h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>Regress the funding rates to the swap return at different enter/exit time. Here we are trying to look for statistically significant (ideally, negative) correlation between the two. Since a negative correlation would imply additional gain from price change on top of the funding profit. We only consider entering a contract if the funding is outside twice of its 60-day historical rolling standard deviations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_on_rolling_std</span><span class="params">(df, window, sigma_band, t1, t2, run_reg=False, show_summary=False, show_coef=True)</span>:</span></span><br><span class="line">    df_sigma = df.copy()</span><br><span class="line">    df_sigma[<span class="string">'sigma'</span>] = df_sigma.fundingRate.rolling(window).std()</span><br><span class="line">    df_sigma = df_sigma.fillna(method = <span class="string">'ffill'</span>).dropna()</span><br><span class="line">    df_sigma = df_sigma.loc[(df_sigma.fundingRate &gt; sigma_band * df_sigma.sigma) | (df_sigma.fundingRate &lt; -sigma_band * df_sigma.sigma)]</span><br><span class="line">    <span class="keyword">if</span> run_reg:</span><br><span class="line">        y = np.array(df_sigma[<span class="string">'swapRet'</span>])</span><br><span class="line">        X = np.array(df_sigma[[<span class="string">'fundingRate'</span>]])</span><br><span class="line">        X = sm.add_constant(X)</span><br><span class="line">        model = sm.OLS(y,X).fit()</span><br><span class="line"></span><br><span class="line">        coef = model.params[<span class="number">1</span>].round(<span class="number">4</span>)</span><br><span class="line">        pval = model.pvalues[<span class="number">0</span>].round(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> show_summary:</span><br><span class="line">            print(model.summary())</span><br><span class="line">        <span class="keyword">if</span> show_coef:</span><br><span class="line">            print(<span class="string">'enter'</span>, t1, <span class="string">'exit'</span>, t2, <span class="string">'coef'</span>, coef, <span class="string">'pval'</span>, pval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_sigma, coef, pval</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">comp_exit = pd.DataFrame(columns=[<span class="string">'exit time'</span>, <span class="string">'coef'</span>, <span class="string">'pval'</span>])</span><br><span class="line">t1 = <span class="number">-100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="number">481</span>, <span class="number">10</span>):</span><br><span class="line">    t2=i</span><br><span class="line"></span><br><span class="line">    df = swap.join([funding])</span><br><span class="line">    df[<span class="string">'swapRet'</span>] = df.swapPrice.shift(-t2) / df.swapPrice.shift(-t1) - <span class="number">1</span></span><br><span class="line">    df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    df_sigma, coef, pval = filter_on_rolling_std(df, <span class="number">180</span>, <span class="number">2</span>, t1, t2, <span class="keyword">True</span>, show_coef=<span class="keyword">False</span>)</span><br><span class="line">    comp_exit = comp_exit.append(&#123;<span class="string">'exit time'</span>: t2, <span class="string">'coef'</span>: coef, <span class="string">'pval'</span>: pval&#125;, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">comp_exit = comp_exit.set_index(<span class="string">'exit time'</span>)</span><br><span class="line">plt.plot(comp_exit)</span><br><span class="line">plt.axhline(y=<span class="number">0.05</span>, color=<span class="string">'grey'</span>, linestyle=<span class="string">'dashed'</span>)</span><br><span class="line">plt.legend(comp_exit.columns, frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Exit Time'</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>, <span class="number">481</span>, step=<span class="number">60</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_13_0.png" alt="png"></p>
<p>Here we observe that as exit time becomes longer, the coefficient becomes more negative and p-value of the coefficient indicates higher significance. Thus we would want to hold the swap position more than 360 minutes/6 hours. Next we look at the impact from entry time.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">comp_enter = pd.DataFrame(columns=[<span class="string">'enter time'</span>, <span class="string">'coef'</span>, <span class="string">'pval'</span>])</span><br><span class="line">t1 = <span class="number">-60</span></span><br><span class="line">t2 = <span class="number">420</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">-120</span>, <span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">    t1=i</span><br><span class="line"></span><br><span class="line">    df = swap.join([funding])</span><br><span class="line">    df[<span class="string">'swapRet'</span>] = df.swapPrice.shift(-t2) / df.swapPrice.shift(-t1) - <span class="number">1</span></span><br><span class="line">    df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> t1 == <span class="number">-60</span>:</span><br><span class="line">        df_sigma, coef, pval = filter_on_rolling_std(df, <span class="number">180</span>, <span class="number">2</span>, t1, t2, <span class="keyword">True</span>, show_summary=<span class="keyword">True</span>, show_coef=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        df_sigma, coef, pval = filter_on_rolling_std(df, <span class="number">180</span>, <span class="number">2</span>, t1, t2, <span class="keyword">True</span>, show_coef=<span class="keyword">False</span>)</span><br><span class="line">    comp_enter = comp_enter.append(&#123;<span class="string">'enter time'</span>: t1, <span class="string">'coef'</span>: coef, <span class="string">'pval'</span>: pval&#125;, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">comp_enter = comp_enter.set_index(<span class="string">'enter time'</span>)</span><br><span class="line">plt.plot(comp_enter)</span><br><span class="line">plt.axhline(y=<span class="number">0.05</span>, color=<span class="string">'grey'</span>, linestyle=<span class="string">'dashed'</span>)</span><br><span class="line">plt.legend(comp_enter.columns, frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Enter Time'</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">-120</span>, <span class="number">0</span>, step=<span class="number">30</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_14_1.png" alt="png"></p>
<p>Similar trends are observed in the entry times and that earlier the entry, the more profit it seems to imply from price changes. We show a summary of the regression at enter time<script type="math/tex">=-60</script> minutes and exit time<script type="math/tex">=420</script> minutes. There is  a moderate R-square of 0.039 and high significance in coefficient which suggest a mean reversion in price given that specific time window.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                            OLS Regression Results                            </span><br><span class="line">==============================================================================</span><br><span class="line">Dep. Variable:                      y   R-squared:                       0.039</span><br><span class="line">Model:                            OLS   Adj. R-squared:                  0.036</span><br><span class="line">Method:                 Least Squares   F-statistic:                     10.46</span><br><span class="line">Date:                Thu, 05 Dec 2019   Prob (F-statistic):            0.00138</span><br><span class="line">Time:                        03:38:11   Log-Likelihood:                 552.01</span><br><span class="line">No. Observations:                 257   AIC:                            -1100.</span><br><span class="line">Df Residuals:                     255   BIC:                            -1093.</span><br><span class="line">Df Model:                           1                                         </span><br><span class="line">Covariance Type:            nonrobust                                         </span><br><span class="line">==============================================================================</span><br><span class="line">                 coef    std err          t      P&gt;|t|      [0.025      0.975]</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">const          0.0035      0.002      1.809      0.072      -0.000       0.007</span><br><span class="line">x1            -2.2357      0.691     -3.235      0.001      -3.597      -0.875</span><br><span class="line">==============================================================================</span><br><span class="line">Omnibus:                       17.788   Durbin-Watson:                   2.247</span><br><span class="line">Prob(Omnibus):                  0.000   Jarque-Bera (JB):               54.546</span><br><span class="line">Skew:                           0.089   Prob(JB):                     1.43e-12</span><br><span class="line">Kurtosis:                       5.250   Cond. No.                         391.</span><br><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br></pre></td></tr></table></figure>
<h1 id="Strategy-1"><a href="#Strategy-1" class="headerlink" title="Strategy"></a>Strategy</h1><p>Based on the research above, this strategy will enter into a swap agreement to collect funding at <script type="math/tex">t1= -1H</script> and exit at <script type="math/tex">t2= +7H</script>. At <script type="math/tex">t2</script>, if the next funding does not fall outside of the 2-sigma band <strong>AND</strong> if we are in a position to collect the next funding, we will test two choices of</p>
<ul>
<li>holding for <script type="math/tex">1H</script> more and exit after colllecting the funding</li>
<li>exiting</li>
</ul>
<p>We will test the impact of a 10bps fee + slippage on each trade.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">t1 = <span class="number">-60</span></span><br><span class="line">t2 = <span class="number">420</span></span><br><span class="line">window = <span class="number">180</span></span><br><span class="line">sigma_band = <span class="number">2</span></span><br><span class="line">fee = <span class="number">0.0010</span> <span class="comment"># per two trades</span></span><br><span class="line"></span><br><span class="line">df = swap.join([funding])</span><br><span class="line">df[<span class="string">'swapRet'</span>]   = df.swapPrice.shift(-t2) / df.swapPrice.shift(-t1) - <span class="number">1</span></span><br><span class="line">df[<span class="string">'swapRet1H'</span>] = df.swapPrice.shift(<span class="number">1</span>) / df.swapPrice.shift(-t1) - <span class="number">1</span></span><br><span class="line">df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">df[<span class="string">'sigma'</span>] = df.fundingRate.rolling(window).std()</span><br><span class="line">df.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">df[<span class="string">'pnl'</span>] = np.where((df.fundingRate &gt; sigma_band*df.sigma) \</span><br><span class="line">                    | (df.fundingRate &lt; -sigma_band*df.sigma), \</span><br><span class="line">                    <span class="number">1</span> + np.abs(df.fundingRate) + \</span><br><span class="line">                    df.swapRet * -np.sign(df.fundingRate), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">'pnlOptimized'</span>] = np.where((df.pnl != <span class="number">1</span>) &amp; (df.pnl.shift(<span class="number">-1</span>) == <span class="number">1</span>) \</span><br><span class="line">                              &amp; (np.sign(df.fundingRate) == np.sign(df.fundingRate.shift(<span class="number">-1</span>))),</span><br><span class="line">                              df.pnl + np.abs(df.fundingRate.shift(<span class="number">-1</span>)) + \</span><br><span class="line">                              df.swapRet1H.shift(<span class="number">-1</span>) * -np.sign(df.fundingRate.shift(<span class="number">-1</span>)), df.pnl)</span><br><span class="line"></span><br><span class="line">df[<span class="string">'pnlFee'</span>] = np.where((df.pnl != <span class="number">1</span>) &amp; (df.pnl.shift(<span class="number">1</span>) == <span class="number">1</span>), df.pnl - fee, df.pnl) <span class="comment"># enter fee</span></span><br><span class="line">df[<span class="string">'pnlFee'</span>] = np.where((df.pnl != <span class="number">1</span>) &amp; (df.pnl.shift(<span class="number">-1</span>) == <span class="number">1</span>), df.pnlFee - fee, df.pnlFee) <span class="comment"># exit fee</span></span><br><span class="line">df[<span class="string">'pnlFee'</span>] = np.where((df.pnl != <span class="number">1</span>) &amp; (df.pnl.shift(<span class="number">1</span>) != <span class="number">1</span>) \</span><br><span class="line">                        &amp; (np.sign(df.fundingRate) != np.sign(df.fundingRate.shift(<span class="number">1</span>))),</span><br><span class="line">                        df.pnlFee - fee, df.pnlFee) <span class="comment"># change position enter fee</span></span><br><span class="line">df[<span class="string">'pnlFee'</span>] = np.where((df.pnl != <span class="number">1</span>) &amp; (df.pnl.shift(<span class="number">-1</span>) != <span class="number">1</span>) \</span><br><span class="line">                        &amp; (np.sign(df.fundingRate) != np.sign(df.fundingRate.shift(<span class="number">-1</span>))),</span><br><span class="line">                        df.pnlFee - fee, df.pnlFee) <span class="comment"># change position exit fee</span></span><br><span class="line">disp(df.iloc[<span class="number">289</span>:<span class="number">293</span>])</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>swapPrice</th>
      <th>fundingRate</th>
      <th>swapRet</th>
      <th>swapRet1H</th>
      <th>sigma</th>
      <th>pnl</th>
      <th>pnlOptimized</th>
      <th>pnlFee</th>
    </tr>
    <tr>
      <th>timestamp</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2016-11-16 20:00:00+00:00</th>
      <td>748.1800</td>
      <td>0.000264</td>
      <td>0.008467</td>
      <td>0.014128</td>
      <td>0.001042</td>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>2016-11-17 04:00:00+00:00</th>
      <td>744.8734</td>
      <td>0.003750</td>
      <td>0.008865</td>
      <td>0.001431</td>
      <td>0.001066</td>
      <td>0.994885</td>
      <td>0.994885</td>
      <td>0.993885</td>
    </tr>
    <tr>
      <th>2016-11-17 20:00:00+00:00</th>
      <td>742.2400</td>
      <td>0.003140</td>
      <td>-0.007095</td>
      <td>-0.001269</td>
      <td>0.001081</td>
      <td>1.010235</td>
      <td>1.008677</td>
      <td>1.009235</td>
    </tr>
    <tr>
      <th>2016-11-18 04:00:00+00:00</th>
      <td>740.0665</td>
      <td>0.001242</td>
      <td>0.012663</td>
      <td>0.002800</td>
      <td>0.001080</td>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(df.pnl.cumprod(), c=<span class="string">'black'</span>)</span><br><span class="line">plt.plot(df.pnlOptimized.cumprod(), c=<span class="string">'tab:blue'</span>)</span><br><span class="line">plt.plot(df.pnlFee.cumprod(), c=<span class="string">'grey'</span>)</span><br><span class="line">plt.legend([<span class="string">'PNL'</span>, <span class="string">'PNL optimized'</span>, <span class="string">'PNL with fee (not optimized)'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_18_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtest_metric</span><span class="params">(df, pnl_column, mdd_interval=<span class="number">180</span>)</span>:</span></span><br><span class="line">    pnl = round(df[pnl_column].cumprod()[<span class="number">-1</span>], <span class="number">4</span>)</span><br><span class="line">    spr = round(np.mean(df[pnl_column]<span class="number">-1</span>) / np.std(df[pnl_column]<span class="number">-1</span>) * np.sqrt(<span class="number">365</span> * <span class="number">3</span>), <span class="number">4</span>)</span><br><span class="line">    mdd = round(np.min((df[pnl_column].cumprod().rolling(mdd_interval).min() \</span><br><span class="line">                        - df[pnl_column].cumprod().shift(mdd_interval)) \</span><br><span class="line">                        / df[pnl_column].cumprod().shift(mdd_interval)), <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> pnl, spr, mdd</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = pd.DataFrame(columns=[<span class="string">'Strategy'</span>, <span class="string">'P&amp;L'</span>, <span class="string">'Sharpe Ratio'</span>, <span class="string">'Maximum Drawdown'</span>])</span><br><span class="line"></span><br><span class="line">pnl, spr, mdd = backtest_metric(df, <span class="string">'pnl'</span>)</span><br><span class="line">result = result.append(&#123;<span class="string">'Strategy'</span>: <span class="string">'Baseline'</span>, <span class="string">'P&amp;L'</span>: pnl,</span><br><span class="line">                        <span class="string">'Sharpe Ratio'</span>: spr, <span class="string">'Maximum Drawdown'</span>: mdd&#125;, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">pnl, spr, mdd = backtest_metric(df, <span class="string">'pnlOptimized'</span>)</span><br><span class="line">result = result.append(&#123;<span class="string">'Strategy'</span>: <span class="string">'Optimized'</span>, <span class="string">'P&amp;L'</span>: pnl,</span><br><span class="line">                        <span class="string">'Sharpe Ratio'</span>: spr, <span class="string">'Maximum Drawdown'</span>: mdd&#125;, ignore_index=<span class="keyword">True</span>)</span><br><span class="line">disp(result)</span><br></pre></td></tr></table></figure>
<table>
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Strategy</th>
      <th>P&amp;L</th>
      <th>Sharpe Ratio</th>
      <th>Maximum Drawdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Baseline</td>
      <td>5.5625</td>
      <td>2.2086</td>
      <td>-0.1438</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Optimized</td>
      <td>6.7478</td>
      <td>2.3101</td>
      <td>-0.1221</td>
    </tr>
  </tbody>
</table>

<p><br><br>We can see that this strategy does provide substantial P&amp;L from the historical periods tested with relatively limited capital exposure. Fees would impact the gains slightly, and using an optimize approach would further improve the performance.</p>
<p><br><br><br></p>
<p>Reference:</p>
<blockquote>
<p><span id="1">[1]</span>: XBTUSD Funding Mean Reversion Strategy, <a href="https://blog.bitmex.com/xbtusd-funding-mean-reversion-strategy/" target="_blank" rel="noopener">https://blog.bitmex.com/xbtusd-funding-mean-reversion-strategy/</a><br><span id="2">[2]</span>: Funding Mean Reversions 2018, <a href="https://blog.bitmex.com/funding-mean-reversions-2018/" target="_blank" rel="noopener">https://blog.bitmex.com/funding-mean-reversions-2018/</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/pi/" class="prev">PREV</a><a href="/2019/06/spx-vol-term-struct/" class="next">NEXT</a></div><div id="container"></div><!-- link(rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css")--><link rel="stylesheet" href="/css/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
    clientID: '4ec287ddd4ac34ff5087',
    clientSecret: 'ae45426765f12ac3e2f903662b8938dc4881f703',
    repo: 'jackliu234.github.io',
    owner: 'jackliu234',
    admin: ['jackliu234'],
    perPage: 100,
    id: 'Sat Jul 20 2019 00:00:00 GMT-0500 GMT'.split('GMT')[0].replace(/\s/g, '-'),
    distractionFreeMode: false,
    pagerDirection: 'first'
})

gitalk.render('container')</script><!-- block copyright--></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-133275176-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>